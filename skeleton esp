--[=[
    Built with TechHog's ScriptBuilder.
    Report bugs directly to TechHog#8984
    or through his discord server at discord.gg/9xHUHFyvR7

    Script: UniversalAimbotAndEspV2
    Files: 12
    Characters: 110,986 (126,398 before minify)
    Lines: 58 (3,587 before minify)
    Build date: 04/29/23
    Minified?: true
    middleclass?: true
]=]
local ModuleExports, ModuleCache, ModuleShared = {},{},{
    oldrequire = require
};
local function require(path)
    if not ModuleCache[path] then
        local module = assert(ModuleExports[path], "Failed to find module named " .. string.format("%q", path));
        ModuleCache[path] = {module()};
    end;
    return unpack(ModuleCache[path]);
end;
ModuleExports.middleclass = (function()local middleclass = { _VERSION = 'middleclass v4.1.1', _DESCRIPTION = 'Object Orientation for Lua', _URL = 'https://github.com/kikito/middleclass', _LICENSE = [[ MIT LICENSE  Copyright (c) 2011 Enrique Garc√≠a Cota  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ]] }  local function _createIndexWrapper(aClass, f) if f == nil then return aClass.__instanceDict elseif type(f) == "function" then return function(self, name) local value = aClass.__instanceDict[name]  if value ~= nil then return value else return (f(self, name)) end end else  return function(self, name) local value = aClass.__instanceDict[name]  if value ~= nil then return value else return f[name] end end end end  local function _propagateInstanceMethod(aClass, name, f) f = name == "__index" and _createIndexWrapper(aClass, f) or f aClass.__instanceDict[name] = f  for subclass in pairs(aClass.subclasses) do if rawget(subclass.__declaredMethods, name) == nil then _propagateInstanceMethod(subclass, name, f) end end end  local function _declareInstanceMethod(aClass, name, f) aClass.__declaredMethods[name] = f  if f == nil and aClass.super then f = aClass.super.__instanceDict[name] end  _propagateInstanceMethod(aClass, name, f) end  local function _tostring(self) return "class " .. self.name end local function _call(self, ...) return self:new(...) end  local function _createClass(name, super) local dict = {} dict.__index = dict  local aClass = { name = name, super = super, static = {}, __instanceDict = dict, __declaredMethods = {}, subclasses = setmetatable({}, {__mode='k'}) }  if super then setmetatable(aClass.static, { __index = function(_,k) local result = rawget(dict,k) if result == nil then return super.static[k] end return result end }) else setmetatable(aClass.static, { __index = function(_,k) return rawget(dict,k) end }) end  setmetatable(aClass, { __index = aClass.static, __tostring = _tostring, __call = _call, __newindex = _declareInstanceMethod })  return aClass end  local function _includeMixin(aClass, mixin) assert(type(mixin) == 'table', "mixin must be a table")  for name,method in pairs(mixin) do if name ~= "included" and name ~= "static" then aClass[name] = method end end  for name,method in pairs(mixin.static or {}) do aClass.static[name] = method end  if type(mixin.included)=="function" then mixin:included(aClass) end return aClass end  local DefaultMixin = { __tostring = function(self) return "instance of " .. tostring(self.class) end,  initialize = function(self, ...) end,  isInstanceOf = function(self, aClass) return type(aClass) == 'table' and type(self) == 'table' and (self.class == aClass or type(self.class) == 'table' and type(self.class.isSubclassOf) == 'function' and self.class:isSubclassOf(aClass)) end,  static = { allocate = function(self) assert(type(self) == 'table', "Make sure that you are using 'Class:allocate' instead of 'Class.allocate'") return setmetatable({ class = self }, self.__instanceDict) end,  new = function(self, ...) assert(type(self) == 'table', "Make sure that you are using 'Class:new' instead of 'Class.new'") local instance = self:allocate() instance:initialize(...) return instance end,  subclass = function(self, name) assert(type(self) == 'table', "Make sure that you are using 'Class:subclass' instead of 'Class.subclass'") assert(type(name) == "string", "You must provide a name(string) for your class")  local subclass = _createClass(name, self)  for methodName, f in pairs(self.__instanceDict) do if not (methodName == "__index" and type(f) == "table") then _propagateInstanceMethod(subclass, methodName, f) end end subclass.initialize = function(instance, ...) return self.initialize(instance, ...) end  self.subclasses[subclass] = true self:subclassed(subclass)  return subclass end,  subclassed = function(self, other) end,  isSubclassOf = function(self, other) return type(other) == 'table' and type(self.super) == 'table' and ( self.super == other or self.super:isSubclassOf(other) ) end,  include = function(self, ...) assert(type(self) == 'table', "Make sure you that you are using 'Class:include' instead of 'Class.include'") for _,mixin in ipairs({...}) do _includeMixin(self, mixin) end return self end } }  function middleclass.class(name, super) assert(type(name) == 'string', "A name (string) is needed for the new class") return super and super:subclass(name) or _includeMixin(_createClass(name), DefaultMixin) end  setmetatable(middleclass, { __call = function(_, ...) return middleclass.class(...) end })  return middleclass 
end);
local function f_module_Signal()
local errhandler = ModuleShared.errhandler; local Connection = {};Connection.__index = Connection; function Connection.new(signal, callback) return signal:_add(setmetatable({ _signal = signal, _callback = callback }, Connection)); end; function Connection:Disconnect() self._signal:remove(self); end; local Signal = {};Signal.__index = Signal; function Signal.new() return setmetatable({ _connections = {} }, Signal); end; function Signal:_add(con) self._connections[con] = true; return con; end; function Signal:_remove(con) self._connections[con] = false; end; function Signal:Connect(callback) return Connection.new(self, callback); end; function Signal:Fire(...) local args = {...}; for connection in next, self._connections do task.spawn(function() xpcall(connection._callback, errhandler"Failed to call connection : ", unpack(args)); end); end; end; return Signal;
end;
ModuleExports["Signal"] = f_module_Signal;
local function f_module_PlayerObject()
local Camera = ModuleShared.Camera; local overrides = ModuleShared.overrides; local Constants = require("Constants"); local FakeConnection = { Disconnect = function(...) end}; local FakeSignal = { Connect = function(...) return FakeConnection; end}; local Utils = require("Utils"); local mathmap = Utils.mathmap; local worldToViewportPoint = Utils.worldToViewportPoint; local replacePairs = Utils.replacePairs; local getTracerFrom = Utils.getTracerFrom; local getLocalRootPart = ModuleShared.getLocalRootPart; local getLocalTeam = ModuleShared.getLocalTeam; local getScreenEdge = ModuleShared.getScreenEdge; local getFieldOfView = ModuleShared.getFieldOfView; local Config = ModuleShared.Config; local function NewNameTag(Name) local NameTag = Drawing.new("Text"); NameTag.Text = Name; NameTag.Size = 20; NameTag.Center = true; NameTag.Font = 1; NameTag.Color = Color3.new(1,1,1); NameTag.Outline = true; NameTag.OutlineColor = Color3.new(0,0,0); return setmetatable({ setColor = function(self) NameTag.Color = Config:get("NAMETAG_COLOR") or Config:get("BASE_COLOR"); return self; end, Remove = function() NameTag:Remove(); end }, {__index = NameTag, __newindex = NameTag}); end; local function NewQuad() local Quad = Drawing.new("Quad"); Quad.Color = Color3.new(1,1,1); Quad.Thickness = 4; Quad.Transparency = 0.55; Quad.Filled = false; return Quad; end; local function NewSquare() local Square = Drawing.new("Square"); Square.Color = Color3.new(1,1,1); Square.Thickness = 4; Square.Transparency = 0.55; Square.Filled = false; return Square; end; local function NewTracer() local Tracer = Drawing.new("Line"); Tracer.Thickness = 3; Tracer.Color = Color3.new(1,1,1); return setmetatable({ setColor = function(self) Tracer.Color = Config:get("TRACER_COLOR") or Config:get("BASE_COLOR"); return self; end, Remove = function() Tracer:Remove(); end }, {__index = Tracer, __newindex = Tracer}); end; local function NewSkeletonLine() local Line = Drawing.new("Line"); Line.Thickness = 3; Line.Color = Color3.new(1,1,1); return Line; end; local _, ConfigChangedSignals = require("Config"); local DistanceCheck = ConfigChangedSignals.ESP_DISTANCE_CHECK; local MaxDistance = ConfigChangedSignals.ESP_MAX_DISTANCE; local TeamCheck = ConfigChangedSignals.ESP_TEAM_CHECK; local BoxThickness = ConfigChangedSignals.BOX_THICKNESS; local BoxTransparency = ConfigChangedSignals.BOX_TRANSPARENCY; local BoxFilled = ConfigChangedSignals.BOX_FILLED local SkeletonThickness = ConfigChangedSignals.SKELETON_THICKNESS; local SkeletonTransparency = ConfigChangedSignals.SKELETON_TRANSPARENCY local BaseColor = ConfigChangedSignals.BASE_COLOR; local NametagColor = ConfigChangedSignals.NAMETAG_COLOR; local BoxColor = ConfigChangedSignals.BOX_COLOR; local TracerColor = ConfigChangedSignals.TRACER_COLOR; local SkeletonColor = ConfigChangedSignals.SKELETON_COLOR; local SkeletonMT = { __index = { Remove = function(self) for _,line in next, self do line:Remove(); end; end, setColor = function(self) self.Color = Config:get("SKELETON_COLOR") or Config:get("BASE_COLOR"); return self; end }, __newindex = function(self, key, value) for _, line in next, self do line[key] = value; end; end}; return ModuleShared.NewModule("Player_Object", { initialize = function(self, Player, customcam) local PlayerIsTable = type(Player) == "table"; self.Camera = customcam or Camera; self.Player = Player; self.Name = Player.Name; self.DistanceCheck = Config:get("ESP_DISTANCE_CHECK"); self.MaxDistance = Config:get("ESP_MAX_DISTANCE"); self.TeamCheck = Config:get("ESP_TEAM_CHECK"); self.Team = Player.Team; local CharacterAddedSignal; if PlayerIsTable then CharacterAddedSignal = FakeSignal; else CharacterAddedSignal = overrides:getCharacterAddedSignal(Player); end; self.CharacterAddedConnection = CharacterAddedSignal:Connect(function(Character) self:addCharacter(Character); end);       local Character = overrides:getCharacter(Player); if Character then self:addCharacter(Character); end; self.NameTag = NewNameTag(Player.Name):setColor(); self.FrontBox = NewQuad(); self.BackBox = NewQuad(); self.LeftBox = NewQuad(); self.RightBox = NewQuad();  self.Box2D = NewQuad(); self.Tracer = NewTracer():setColor(); self.Skeleton = setmetatable({ HeadToNeck = NewSkeletonLine(), NeckToLeftShoulder = NewSkeletonLine(), NeckToRightShoulder = NewSkeletonLine(), LeftShoulderToLeftUpperArm = NewSkeletonLine(), RightShoulderToRightUpperArm = NewSkeletonLine(), LeftUpperArmToLeftLowerArm = NewSkeletonLine(), RightUpperArmToRightLowerArm = NewSkeletonLine(), LeftLowerArmToLeftHand = NewSkeletonLine(), RightLowerArmToRightHand = NewSkeletonLine(), NeckToLowerTorso = NewSkeletonLine(), LowerTorsoToLeftUpperLeg = NewSkeletonLine(), LowerTorsoToRightUpperLeg = NewSkeletonLine(), LeftUpperLegToLeftLowerLeg = NewSkeletonLine(), RightUpperLegToRightLowerLeg = NewSkeletonLine(), LeftLowerLegToLeftFoot = NewSkeletonLine(), RightLowerLegToRightFoot = NewSkeletonLine() }, SkeletonMT):setColor(); local function setbox(property, value) self.FrontBox[property] = value; self.BackBox[property] = value; self.LeftBox[property] = value; self.RightBox[property] = value; self.Box2D[property] = value; end; local function setboxcolor() setbox("Color", Config:get("BOX_COLOR") or Config:get("BASE_COLOR")); end; local function setboxthickness(thickness) setbox("Thickness", thickness); end; local function setboxtransparency(transparency) setbox("Transparency", transparency); end; local function setboxfilled(filled) setbox("Filled", filled); end; setboxcolor(); setboxthickness(Config:get("BOX_THICKNESS")); setboxtransparency(Config:get("BOX_TRANSPARENCY")); setboxfilled(Config:get("BOX_FILLED")); self.Connections = { DistanceCheck:Connect(function(new) self.DistanceCheck = new; end), MaxDistance:Connect(function(new) self.MaxDistance = new; end), TeamCheck:Connect(function(new) self.TeamCheck = new; end), Player:GetPropertyChangedSignal("Team"):Connect(function() self.Team = Player.Team; end), BaseColor:Connect(function() self.NameTag:setColor(); setboxcolor(); self.Tracer:setColor(); self.Skeleton:setColor(); end), NametagColor:Connect(function() self.NameTag:setColor(); end), BoxColor:Connect(setboxcolor), TracerColor:Connect(function() self.Tracer:setColor(); end), SkeletonColor:Connect(function() self.Skeleton:setColor(); end), SkeletonThickness:Connect(function(Value) self.Skeleton.Thickness = Value; end), SkeletonTransparency:Connect(function(Value) self.Skeleton.Transparency = Value; end), BoxThickness:Connect(setboxthickness), BoxTransparency:Connect(setboxtransparency), BoxFilled:Connect(setboxfilled), }; end, addCharacter = function(self, Character) self.Character = Character; local Humanoid = self:waitForPart("Humanoid"); if not Humanoid then return self:stop(); end; local IsR6 = Humanoid.RigType == Constants.RIGTYPE_R6; self.Parts = { Humanoid = Humanoid, Head = self:waitForPart("Head"), HumanoidRootPart = self:waitForPart("HumanoidRootPart"), UpperTorso = self:waitForPart(IsR6 and "Torso" or "UpperTorso"), LowerTorso = self:waitForPart(IsR6 and "Torso" or "LowerTorso") }; self.IsR6 = IsR6; if IsR6 then  self.Parts.LeftUpperArm = self:waitForPart("Left Arm"); self.Parts.RightUpperArm = self:waitForPart("Right Arm"); self.Parts.LeftLowerArm = self:waitForPart("Left Arm"); self.Parts.RightLowerArm = self:waitForPart("Right Arm"); self.Parts.LeftHand = self:waitForPart("Left Arm"); self.Parts.RightHand = self:waitForPart("Right Arm"); self.Parts.LeftUpperLeg = self:waitForPart("Left Leg"); self.Parts.RightUpperLeg = self:waitForPart("Right Leg"); self.Parts.LeftLowerLeg = self:waitForPart("Left Leg"); self.Parts.RightLowerLeg = self:waitForPart("Right Leg"); self.Parts.LeftFoot = self:waitForPart("Left Leg"); self.Parts.RightFoot = self:waitForPart("Right Leg"); else self.Parts.LeftUpperArm = self:waitForPart("LeftUpperArm"); self.Parts.RightUpperArm = self:waitForPart("RightUpperArm"); self.Parts.LeftLowerArm = self:waitForPart("LeftLowerArm"); self.Parts.RightLowerArm = self:waitForPart("RightLowerArm"); self.Parts.LeftHand = self:waitForPart("LeftHand"); self.Parts.RightHand = self:waitForPart("RightHand"); self.Parts.LeftUpperLeg = self:waitForPart("LeftUpperLeg"); self.Parts.RightUpperLeg = self:waitForPart("RightUpperLeg"); self.Parts.LeftLowerLeg = self:waitForPart("LeftLowerLeg"); self.Parts.RightLowerLeg = self:waitForPart("RightLowerLeg"); self.Parts.LeftFoot = self:waitForPart("LeftFoot"); self.Parts.RightFoot = self:waitForPart("RightFoot"); end; if not self.Character then return self:stop(); end; self.Alive = true; local DestroyedConnection; DestroyedConnection = overrides:getDestroyedSignal(Character):Connect(function() self.Alive = false; self.Parts = {}; self.Character = nil; DestroyedConnection:Disconnect(); end); end, waitForPart = function(self, partName)                 local char; local result; local count = 0; while true do char = self.Character; if (not char) or (count > 5) then return; end; result = char:FindFirstChild(partName); if result then return result;end; task.wait(0.3); count += 1; end; end, doDistanceCheck = function(self, distance) if not self.DistanceCheck then return true; end; return distance <= self.MaxDistance; end, doTeamCheck = function(self) if not self.TeamCheck then return true; end; local Team, LocalTeam = self.Team, getLocalTeam(); if Team == nil and LocalTeam == nil then return true; end; if Team == LocalTeam then return false; end; return true; end, render = function(self) local NameTag = self.NameTag; NameTag.Visible = false; local FrontBox = self.FrontBox; local BackBox = self.BackBox; local LeftBox = self.LeftBox; local RightBox = self.RightBox; local Box2D = self.Box2D; FrontBox.Visible = false; BackBox.Visible = false; LeftBox.Visible = false; RightBox.Visible = false; Box2D.Visible = false; local Tracer = self.Tracer; Tracer.Visible = false; local Skeleton = self.Skeleton; Skeleton.Visible = false; if not self:doTeamCheck() then return; end; local Parts = self.Parts; if not Parts or not next(Parts) then return; end; local Head = Parts.Head; local RootPart = Parts.UpperTorso; local LowerTorso = Parts.LowerTorso; local LeftUpperArm = Parts.LeftUpperArm; local RightUpperArm = Parts.RightUpperArm; local LeftLowerArm = Parts.LeftLowerArm; local RightLowerArm = Parts.RightLowerArm; local LeftHand = Parts.LeftHand; local RightHand = Parts.RightHand; local LeftUpperLeg = Parts.LeftUpperLeg; local RightUpperLeg = Parts.RightUpperLeg; local LeftLowerLeg = Parts.LeftLowerLeg; local RightLowerLeg = Parts.RightLowerLeg; local LeftFoot = Parts.LeftFoot; local RightFoot = Parts.RightFoot; if not Head or not RootPart then return; end; local cam = self.Camera; local Distance = (getLocalRootPart() and math.round((getLocalRootPart().Position - RootPart.Position).Magnitude)) or "N/A"; if not self:doDistanceCheck(Distance) then return; end; self:renderNameTag(Head, NameTag, cam, Parts.Humanoid, tostring(Distance)); local BoxEnabled = Config:get("BOX_ENABLED"); if BoxEnabled then local Box2DEnabled = Config:get("2DBOX_ENABLED"); local Box3DEnabled = Config:get("3DBOX_ENABLED"); if Box2DEnabled or Box3DEnabled then self:renderBoxes(RootPart, cam, Box3DEnabled, Box2DEnabled, FrontBox, BackBox, LeftBox, RightBox, Config:get("3DBOX_VERTICAL_OFFSET"), Box2D); end; end; self:renderTracer(Config:get("TRACER_ENABLED"), cam, Tracer); self:renderSkeleton(Skeleton, Head, cam, LeftUpperArm, RightUpperArm, LeftLowerArm, RightLowerArm, LeftHand, RightHand, LowerTorso, LeftUpperLeg, RightUpperLeg, LeftLowerLeg, RightLowerLeg, LeftFoot, RightFoot); end, renderNameTag = function(self, Head, NameTag, cam, Humanoid, Distance) if not Config:get("NAMETAG_ENABLED") then return; end; local NameTagPosition, NameTagIsVisible, NametagDepth = worldToViewportPoint(Head.Position + Config:get("NAMETAG_3D_VERTICAL_OFFSET"), cam); if not NameTagIsVisible then return; end; NameTag.Visible = true; NameTag.Position = NameTagPosition; NameTag.Text = replacePairs(Config:get("NAMETAG_TEXT"), "NAME", self.Name, "HEALTH", Humanoid.Health, "MAXHEALTH", Humanoid.MaxHealth, "DISTANCE", Distance); local max = Config:get("MAXIMUM_TEXT_SIZE"); local min = math.min(Config:get("MINIMUM_TEXT_SIZE"), max); NameTag.Size = math.clamp(math.round(mathmap(NametagDepth, getFieldOfView(), 1, min, max)), min, max); end, renderBoxes = function(self, RootPart, cam, Box3DEnabled, Box2DEnabled, FrontBox, BackBox, LeftBox, RightBox, BoxVerticalOffset, Box2D) local RootPartPosition, RootPartIsVisible, RootPartDepth = worldToViewportPoint(RootPart.Position, cam); if not RootPartIsVisible then return; end; self:renderBox3D(Box3DEnabled, FrontBox, BackBox, LeftBox, RightBox, RootPart, BoxVerticalOffset, cam); self:renderBox2D(Box2DEnabled, Box2D, RootPartDepth, RootPartPosition); end, renderBox3D = function(_, Box3DEnabled, FrontBox, BackBox, LeftBox, RightBox, RootPart, BoxVerticalOffset, cam) if not Box3DEnabled then return; end; FrontBox.Visible = true; BackBox.Visible = true; LeftBox.Visible = true; RightBox.Visible = true; local RightVector = RootPart.CFrame.RightVector; local LookVector = RootPart.CFrame.LookVector / 4; local FrontTopRightPos = worldToViewportPoint(RootPart.Position + BoxVerticalOffset + RightVector + LookVector, cam); local FrontTopLeftPos = worldToViewportPoint(RootPart.Position + BoxVerticalOffset - RightVector + LookVector, cam); local FrontBottomLeftPos = worldToViewportPoint(RootPart.Position - BoxVerticalOffset - RightVector + LookVector, cam); local FrontBottomRightPos = worldToViewportPoint(RootPart.Position - BoxVerticalOffset + RightVector + LookVector, cam); FrontBox.PointA = FrontTopRightPos; FrontBox.PointB = FrontTopLeftPos; FrontBox.PointC = FrontBottomLeftPos; FrontBox.PointD = FrontBottomRightPos; local BackTopRightPos = worldToViewportPoint(RootPart.Position + BoxVerticalOffset + RightVector - LookVector, cam); local BackTopLeftPos = worldToViewportPoint(RootPart.Position + BoxVerticalOffset - RightVector - LookVector, cam); local BackBottomLeftPos = worldToViewportPoint(RootPart.Position - BoxVerticalOffset - RightVector - LookVector, cam); local BackBottomRightPos = worldToViewportPoint(RootPart.Position - BoxVerticalOffset + RightVector - LookVector, cam); BackBox.PointA = BackTopRightPos; BackBox.PointB = BackTopLeftPos; BackBox.PointC = BackBottomLeftPos; BackBox.PointD = BackBottomRightPos; LeftBox.PointA = FrontTopLeftPos; LeftBox.PointB = BackTopLeftPos; LeftBox.PointC = BackBottomLeftPos; LeftBox.PointD = FrontBottomLeftPos; RightBox.PointA = FrontTopRightPos; RightBox.PointB = BackTopRightPos; RightBox.PointC = BackBottomRightPos; RightBox.PointD = FrontBottomRightPos; end, renderBox2D = function(_, Box2DEnabled, Box2D, RootPartDepth, RootPartPosition) if not Box2DEnabled then return; end; Box2D.Visible = true; local X = getScreenEdge().X / (RootPartDepth + 20); local Y = getScreenEdge().Y / (RootPartDepth + 10); Box2D.PointA = Vector2.new(RootPartPosition.X + X, RootPartPosition.Y + Y); Box2D.PointB = Vector2.new(RootPartPosition.X - X, RootPartPosition.Y + Y); Box2D.PointC = Vector2.new(RootPartPosition.X - X, RootPartPosition.Y - Y); Box2D.PointD = Vector2.new(RootPartPosition.X + X, RootPartPosition.Y - Y); end, renderTracer = function(self, TracerEnabled, cam, Tracer) if not TracerEnabled then return; end; local TracerPart = self:waitForPart(Config:get("TRACER_PART")); if TracerPart then local Pos, IsVisible = worldToViewportPoint(TracerPart.Position, cam); if IsVisible then Tracer.Visible = true; Tracer.To = Pos; Tracer.From = getTracerFrom(3);  end; end; end, renderSkeleton = function(self, Skeleton, Head, cam, LeftUpperArm, RightUpperArm, LeftLowerArm, RightLowerArm, LeftHand, RightHand, LowerTorso, LeftUpperLeg, RightUpperLeg, LeftLowerLeg, RightLowerLeg, LeftFoot, RightFoot) if not Config:get("SKELETON_ENABLED") then return; end; local NeckPosition = self:renderHeadToNeck(Skeleton, Head, cam); local LeftShoulderPosition, RightShoulderPosition = self:renderNeckToShoulders(LeftUpperArm, RightUpperArm, cam, Skeleton, NeckPosition); local LeftUpperArmPosition, RightUpperArmPosition = self:renderShouldersToUpperArms(LeftUpperArm, Skeleton, LeftShoulderPosition, RightUpperArm, RightShoulderPosition); local LeftLowerArmPosition, RightLowerArmPosition = self:renderUpperArmsToLowerArms(LeftLowerArm, Skeleton, LeftUpperArmPosition, RightLowerArm, RightUpperArmPosition); self:renderLowerArmsToHands(LeftHand, Skeleton, LeftLowerArmPosition, RightHand, RightLowerArmPosition); local LowerTorsoPosition = self:renderNeckToLowerTorso(LowerTorso, NeckPosition, Skeleton); local LeftUpperLegPosition, RightUpperLegPosition = self:renderLowerTorsoToUpperLegs(LowerTorsoPosition, LeftUpperLeg, Skeleton, RightUpperLeg); local LeftLowerLegPosition, RightLowerLegPosition = self:renderUpperLegsToLowerLegs(LeftLowerLeg, LeftUpperLegPosition, Skeleton, RightLowerLeg, RightUpperLegPosition); self:renderLowerLegsToFeet(LeftFoot, LeftLowerLegPosition, Skeleton, RightFoot, RightLowerLegPosition); end, renderHeadToNeck = function(self, Skeleton, Head, cam) local HeadPosition, HeadIsVisible = worldToViewportPoint(Head.Position, cam); local NeckPosition, NeckIsVisible = worldToViewportPoint(Head.Position - Constants.NECK_OFFSET, cam); if HeadIsVisible and NeckIsVisible then local HeadToNeck = Skeleton.HeadToNeck; HeadToNeck.Visible = true; HeadToNeck.From = HeadPosition; HeadToNeck.To = NeckPosition; end; return (NeckIsVisible and NeckPosition) or nil; end, renderNeckToShoulders = function(self, LeftUpperArm, RightUpperArm, cam, Skeleton, NeckPosition) if not NeckPosition then return; end; local LeftShoulderPosition, LeftShoulderIsVisible = worldToViewportPoint(LeftUpperArm.Position + LeftUpperArm.CFrame.YVector / Constants.VECTOR_DIVIDEND, cam); if LeftShoulderIsVisible then local NeckToLeftShoulder = Skeleton.NeckToLeftShoulder; NeckToLeftShoulder.Visible = true; NeckToLeftShoulder.From = NeckPosition; NeckToLeftShoulder.To = LeftShoulderPosition; end; local RightShoulderPosition, RightShoulderIsVisible = worldToViewportPoint(RightUpperArm.Position + RightUpperArm.CFrame.YVector / Constants.VECTOR_DIVIDEND, cam); if RightShoulderIsVisible then local NeckToRightShoulder = Skeleton.NeckToRightShoulder; NeckToRightShoulder.Visible = true; NeckToRightShoulder.From = NeckPosition; NeckToRightShoulder.To = RightShoulderPosition; end; return (LeftShoulderIsVisible and LeftShoulderPosition) or nil, (RightShoulderIsVisible and RightShoulderPosition) or nil; end, renderShouldersToUpperArms = function(self, LeftUpperArm, Skeleton, LeftShoulderPosition, RightUpperArm, RightShoulderPosition) local LeftUpperArmPosition, LeftUpperArmIsVisible = worldToViewportPoint(LeftUpperArm.Position - LeftUpperArm.CFrame.UpVector / Constants.VECTOR_DIVIDEND - LeftUpperArm.CFrame.XVector / Constants.XVECTOR_DIVIDEND); if LeftShoulderPosition and LeftUpperArmIsVisible then local LeftShoulderToLeftUpperArm = Skeleton.LeftShoulderToLeftUpperArm; LeftShoulderToLeftUpperArm.Visible = true; LeftShoulderToLeftUpperArm.From = LeftShoulderPosition; LeftShoulderToLeftUpperArm.To = LeftUpperArmPosition; end; local RightUpperArmPosition, RightUpperArmIsVisible = worldToViewportPoint(RightUpperArm.Position - RightUpperArm.CFrame.UpVector / Constants.VECTOR_DIVIDEND + RightUpperArm.CFrame.XVector / Constants.XVECTOR_DIVIDEND); if RightShoulderPosition and RightUpperArmIsVisible then local RightShoulderToRightUpperArm = Skeleton.RightShoulderToRightUpperArm; RightShoulderToRightUpperArm.Visible = true; RightShoulderToRightUpperArm.From = RightShoulderPosition; RightShoulderToRightUpperArm.To = RightUpperArmPosition; end; return (LeftUpperArmIsVisible and LeftUpperArmPosition) or nil, (RightUpperArmIsVisible and RightUpperArmPosition) or nil; end, renderUpperArmsToLowerArms = function(self, LeftLowerArm, Skeleton, LeftUpperArmPosition, RightLowerArm, RightUpperArmPosition) local LeftLowerArmPosition, LeftLowerArmIsVisible = worldToViewportPoint(LeftLowerArm.Position - LeftLowerArm.CFrame.UpVector / Constants.VECTOR_DIVIDEND - LeftLowerArm.CFrame.XVector / Constants.XVECTOR_LOWER_DIVIDEND); if LeftUpperArmPosition and LeftLowerArmIsVisible then local LeftUpperArmToLeftLowerArm = Skeleton.LeftUpperArmToLeftLowerArm; LeftUpperArmToLeftLowerArm.Visible = true; LeftUpperArmToLeftLowerArm.From = LeftUpperArmPosition; LeftUpperArmToLeftLowerArm.To = LeftLowerArmPosition; end; local RightLowerArmPosition, RightLowerArmIsVisible = worldToViewportPoint(RightLowerArm.Position - RightLowerArm.CFrame.UpVector / Constants.VECTOR_DIVIDEND + RightLowerArm.CFrame.XVector / Constants.XVECTOR_LOWER_DIVIDEND); if RightUpperArmPosition and RightLowerArmIsVisible then local RightUpperArmToRightLowerArm = Skeleton.RightUpperArmToRightLowerArm; RightUpperArmToRightLowerArm.Visible = true; RightUpperArmToRightLowerArm.From = RightUpperArmPosition; RightUpperArmToRightLowerArm.To = RightLowerArmPosition; end; return (LeftLowerArmIsVisible and LeftLowerArmPosition) or nil, (RightLowerArmIsVisible and RightLowerArmPosition) or nil; end, renderLowerArmsToHands = function(self, LeftHand, Skeleton, LeftLowerArmPosition, RightHand, RightLowerArmPosition) local LeftHandPosition, LeftHandIsVisible = worldToViewportPoint(LeftHand.Position); if LeftLowerArmPosition and LeftHandIsVisible then local LeftLowerArmToLeftHand = Skeleton.LeftLowerArmToLeftHand; LeftLowerArmToLeftHand.Visible = true; LeftLowerArmToLeftHand.From = LeftLowerArmPosition; LeftLowerArmToLeftHand.To = LeftHandPosition; end; local RightHandPosition, RightHandIsVisible = worldToViewportPoint(RightHand.Position); if RightLowerArmPosition and RightHandIsVisible then local RightLowerArmToRightHand = Skeleton.RightLowerArmToRightHand; RightLowerArmToRightHand.Visible = true; RightLowerArmToRightHand.From = RightLowerArmPosition; RightLowerArmToRightHand.To = RightHandPosition; end; return (LeftHandIsVisible and LeftHandPosition) or nil, (RightHandIsVisible and RightHandPosition) or nil; end, renderNeckToLowerTorso = function(self, LowerTorso, NeckPosition, Skeleton) local LowerTorsoPosition, LowerTorsoIsVisible = worldToViewportPoint(LowerTorso.Position); if NeckPosition and LowerTorsoIsVisible then local NeckToLowerToro = Skeleton.NeckToLowerTorso; NeckToLowerToro.Visible = true; NeckToLowerToro.From = NeckPosition; NeckToLowerToro.To = LowerTorsoPosition; end; return (LowerTorsoIsVisible and LowerTorsoPosition) or nil; end, renderLowerTorsoToUpperLegs = function(self, LowerTorsoPosition, LeftUpperLeg, Skeleton, RightUpperLeg) if not LowerTorsoPosition then return; end; local LeftUpperLegPosition, LeftUpperLegIsVisible = worldToViewportPoint(LeftUpperLeg.Position + LeftUpperLeg.CFrame.UpVector / Constants.VECTOR_DIVIDEND); if LeftUpperLegIsVisible then local LowerTorsoToLeftUpperLeg = Skeleton.LowerTorsoToLeftUpperLeg; LowerTorsoToLeftUpperLeg.Visible = true; LowerTorsoToLeftUpperLeg.From = LowerTorsoPosition; LowerTorsoToLeftUpperLeg.To = LeftUpperLegPosition; end; local RightUpperLegPosition, RightUpperLegIsVisible = worldToViewportPoint(RightUpperLeg.Position + RightUpperLeg.CFrame.UpVector / Constants.VECTOR_DIVIDEND); if RightUpperLegIsVisible then local LowerTorsoToRightUpperLeg = Skeleton.LowerTorsoToRightUpperLeg; LowerTorsoToRightUpperLeg.Visible = true; LowerTorsoToRightUpperLeg.From = LowerTorsoPosition; LowerTorsoToRightUpperLeg.To = RightUpperLegPosition; end; return (LeftUpperLegIsVisible and LeftUpperLegPosition) or nil, (RightUpperLegIsVisible and RightUpperLegPosition) or nil; end, renderUpperLegsToLowerLegs = function(self, LeftLowerLeg, LeftUpperLegPosition, Skeleton, RightLowerLeg, RightUpperLegPosition) local LeftLowerLegPosition, LeftLowerLegIsVisible = worldToViewportPoint(LeftLowerLeg.Position + LeftLowerLeg.CFrame.UpVector / Constants.VECTOR_DIVIDEND); if LeftUpperLegPosition and LeftLowerLegIsVisible then local LeftUpperLegToLeftLowerLeg = Skeleton.LeftUpperLegToLeftLowerLeg; LeftUpperLegToLeftLowerLeg.Visible = true; LeftUpperLegToLeftLowerLeg.From = LeftUpperLegPosition; LeftUpperLegToLeftLowerLeg.To = LeftLowerLegPosition; end; local RightLowerLegPosition, RightLowerLegIsVisible = worldToViewportPoint(RightLowerLeg.Position + RightLowerLeg.CFrame.UpVector / Constants.VECTOR_DIVIDEND); if RightUpperLegPosition and RightLowerLegIsVisible then local RightUpperLegToRightLowerLeg = Skeleton.RightUpperLegToRightLowerLeg; RightUpperLegToRightLowerLeg.Visible = true; RightUpperLegToRightLowerLeg.From = RightUpperLegPosition; RightUpperLegToRightLowerLeg.To = RightLowerLegPosition; end; return (LeftLowerLegIsVisible and LeftLowerLegPosition) or nil, (RightLowerLegIsVisible and RightLowerLegPosition) or nil; end, renderLowerLegsToFeet = function(self, LeftFoot, LeftLowerLegPosition, Skeleton, RightFoot, RightLowerLegPosition) local LeftFootPosition, LeftFootIsVisible = worldToViewportPoint(LeftFoot.Position); if LeftLowerLegPosition and LeftFootIsVisible then local LeftLowerLegToLeftFoot = Skeleton.LeftLowerLegToLeftFoot; LeftLowerLegToLeftFoot.Visible = true; LeftLowerLegToLeftFoot.From = LeftLowerLegPosition; LeftLowerLegToLeftFoot.To = LeftFootPosition; end; local RightFootPosition, RightFootIsVisible = worldToViewportPoint(RightFoot.Position); if RightLowerLegPosition and RightFootIsVisible then local RightLowerLegToRightFoot = Skeleton.RightLowerLegToRightFoot; RightLowerLegToRightFoot.Visible = true; RightLowerLegToRightFoot.From = RightLowerLegPosition; RightLowerLegToRightFoot.To = RightFootPosition; end; return (LeftFootIsVisible and LeftFootPosition) or nil, (RightFootIsVisible and RightFootPosition) or nil; end, stop = function(self)  self.Character = nil; self.Parts = nil; if self.NameTag then self.NameTag:Remove(); end; if self.FrontBox then self.FrontBox:Remove(); end; if self.BackBox then self.BackBox:Remove(); end; if self.LeftBox then self.LeftBox:Remove(); end; if self.RightBox then self.RightBox:Remove(); end; if self.Box2D then self.Box2D:Remove(); end; if self.Tracer then self.Tracer:Remove(); end; if self.Skeleton then self.Skeleton:Remove(); end; if self.CharacterAddedConnection then self.CharacterAddedConnection:Disconnect(); end; if self.Connections then for _, Connection in next, self.Connections do pcall(Connection.Disconnect, Connection); end; end; end});
end;
ModuleExports["PlayerObject"] = f_module_PlayerObject;
local function f_module_AutoEntryTable()
local AutoEntryTable = {}; local function default_getvalue(...) return {}; end; function AutoEntryTable.new(getvalue) getvalue = getvalue or default_getvalue; return setmetatable({}, { __index = function(self, key) self[key] = getvalue(key); return self[key]; end; }); end; return setmetatable(AutoEntryTable, {__call = function(self, ...) return self.new(...); end});
end;
ModuleExports["AutoEntryTable"] = f_module_AutoEntryTable;
local function f_module_ui()
local ScreenGui = require("ui/ui"); local Tween = require("Tween"); local Constants = require("Constants"); local Utils = require("Utils"); local Shared = ModuleShared.Shared; local mathmap = Utils.mathmap; local mathround = Utils.mathround; local getKeyFromInput = Utils.getKeyFromInput; local Config = ModuleShared.Config; local _, ConfigChangedSignals, InitialValues, DefaultsLookup, UISections = require("Config"); local NumberUsePlaceholderText = ConfigChangedSignals.NUMBER_USE_PLACEHOLDER_TEXT; local TextUsePlaceholderText = ConfigChangedSignals.TEXT_USE_PLACEHOLDER_TEXT; local StructUsePlaceholderText = ConfigChangedSignals.STRUCT_USE_PLACEHOLDER_TEXT; local MOUSEBUTTON1 = Constants.MOUSEBUTTON1; local INPUT_BEGAN = Constants.INPUT_BEGAN; local INPUT_CHANGED = Constants.INPUT_CHANGED; local KEYCODE_ESCAPE = Enum.KeyCode.Escape; local CONTEXT_ACTION_SERVICE = Constants.CONTEXT_ACTION_SERVICE; local PASS = Enum.ContextActionResult.Pass; local BEGIN = Constants.BEGIN; local CANCEL = Constants.CANCEL; local END = Constants.END; local ContextWhitelist = Enum.KeyCode:GetEnumItems(); for item in next, Constants.KEYBIND_USER_INPUT_TYPE_WHITELIST do table.insert(ContextWhitelist, item); end; local MainFrame = ScreenGui.MainFrame; local TopBar = MainFrame.TopBar; local Panels = MainFrame.Panels; local PromptHolder = MainFrame.PromptHolder; local ConfigPanel = Panels.ConfigPanel; local ConfigContainer = ConfigPanel.Container; local ConfigContainerListLayout = ConfigContainer.UIListLayout; ConfigContainer.AutomaticCanvasSize = Enum.AutomaticSize.None; local function isInputEnded(Input) return Input.UserInputState == END or Input.UserInputState == CANCEL; end; do local dragstart, startposition, draginput; local TInfo = TweenInfo.new(0.25, 8); TopBar.InputBegan:Connect(function(Input) if Input.UserInputType ~= MOUSEBUTTON1  then return; end;  dragstart = Input.Position; startposition = MainFrame.Position; local function drag(position) local Delta = position - dragstart; local Position = UDim2.new(startposition.X.Scale, startposition.X.Offset + Delta.X, startposition.Y.Scale, startposition.Y.Offset + Delta.Y); Tween.PlayNew(MainFrame, TInfo, {Position = Position}); end local dragconnection = INPUT_CHANGED:Connect(function(Input) if Input ~= draginput then return; end; drag(Input.Position); end); local Con; Con = Input.Changed:Connect(function() if not isInputEnded(Input) then return; end;  dragconnection:Disconnect(); Con:Disconnect(); end); end); TopBar.InputChanged:Connect(function(Input) if Input.UserInputType ~= Constants.MOUSEMOVEMENT  then return; end; draginput = Input; end); end; local ButtonAnimationsTInfo = TweenInfo.new(0.25, 8); local function setupButtonAnimations(button, content, downCallback) local LeaveColor = content.BackgroundColor3; local EnterColor = Color3.fromRGB(LeaveColor.R * 255 + 18, LeaveColor.G * 255 + 18, LeaveColor.B * 255 + 18); local UpColor = EnterColor; local DownColor = Color3.fromRGB(UpColor.R * 255 + 6, UpColor.G * 255 + 6, UpColor.B * 255 + 6); button.MouseButton1Down:Connect(function() Tween.PlayNew(content, ButtonAnimationsTInfo, {BackgroundColor3 = DownColor}); if not downCallback then return; end; downCallback(); end); button.MouseButton1Up:Connect(function() Tween.PlayNew(content, ButtonAnimationsTInfo, {BackgroundColor3 = UpColor}); end); button.MouseEnter:Connect(function() Tween.PlayNew(content, ButtonAnimationsTInfo, {BackgroundColor3 = EnterColor}); end); button.MouseLeave:Connect(function() Tween.PlayNew(content, ButtonAnimationsTInfo, {BackgroundColor3 = LeaveColor}); end); end; local maximized = true; local maximizedsize = MainFrame.Size; local minimizedsize = UDim2.fromOffset(maximizedsize.X.Offset, TopBar.Size.Y.Offset); local minimizeTInfo = TweenInfo.new(0.25, 8); TopBar.Minimize.MouseButton1Click:Connect(function() maximized = not maximized;  Tween.PlayNew(MainFrame, minimizeTInfo, {Size = (maximized and maximizedsize) or minimizedsize}); Tween.PlayNew(ConfigContainer, minimizeTInfo, {ScrollBarImageTransparency = (maximized and 0) or 1}); Tween.PlayNew(ConfigPanel, minimizeTInfo, {BackgroundTransparency = (maximized and 0) or 1}); end); setupButtonAnimations(TopBar.Minimize, TopBar.Minimize.Label); TopBar.Close.MouseButton1Click:Once(function() Shared.stop(); end); setupButtonAnimations(TopBar.Close, TopBar.Close.Label); TopBar.ResetAll.MouseButton1Click:Connect(function() PromptHolder.Visible = true; end); setupButtonAnimations(TopBar.ResetAll, TopBar.ResetAll.Label); local function closePrompt() PromptHolder.Visible = false; end; local Prompt = PromptHolder.PromptContainer.Prompt; Prompt.YesButton.MouseButton1Click:Connect(function() for _, Pair in next, InitialValues do local Key, Value = Pair[1], Pair[2]; Config:set(Key, Value); end; closePrompt(); end); Prompt.NoButton.MouseButton1Click:Connect(closePrompt); local ToggleTemplate = ConfigContainer.Toggle;ToggleTemplate.Parent = nil; local KeyBindTemplate = ConfigContainer.KeyBind;KeyBindTemplate.Parent = nil; local TextTemplate = ConfigContainer.Text;TextTemplate.Parent = nil; local SliderTemplate = ConfigContainer.Slider;SliderTemplate.Parent = nil; local SeparatorTemplate = ConfigContainer.Separator;SeparatorTemplate.Parent = nil; local ColorTemplate = ConfigContainer.Color;ColorTemplate.Parent = nil; local StructTemplate = ConfigContainer.Struct;StructTemplate.Parent = nil; local StructValueTemplate = StructTemplate.Bottom.Value;StructValueTemplate.Parent = nil; local DropdownTemplate = ConfigContainer.Dropdown;DropdownTemplate.Parent = nil; local DropdownOptionTemplate = DropdownTemplate.Bottom.Template;DropdownOptionTemplate.Parent = nil; local OffColor = ToggleTemplate.Content.Display.BackgroundColor3; local OnColor = Color3.fromRGB(58, 210, 58); local RightClickMenu = MainFrame.RightClickMenu; local RightClickedElement; local function closeRightClickMenu() RightClickMenu.Visible = false; RightClickedElement = nil; end; local function dragObject(obj, callback) local draginput; obj.InputBegan:Connect(function(Input) if Input.UserInputType ~= MOUSEBUTTON1  then return; end; callback(Input.Position); local dragconnection = INPUT_CHANGED:Connect(function(Input) if Input ~= draginput then return; end; callback(Input.Position); end); local Con; Con = Input.Changed:Connect(function() if not isInputEnded(Input) then return; end; dragconnection:Disconnect(); Con:Disconnect(); end); end); obj.InputChanged:Connect(function(Input) if Input.UserInputType ~= Constants.MOUSEMOVEMENT  then return; end; draginput = Input; end); end; local function KEYBIND_GETPOSITION(KeyBind) return UDim2.new(1, -KeyBind.Size.X.Offset - 5, 0, 3); end; local function addKeyBind(Key, KeyBindKey, element, callback, getPosition) local content; if element then content = element.Content; else element = KeyBindTemplate:Clone(); element.Name = Key; element.Parent = ConfigContainer; content = element.Content; content.Label.Text = Key; end; local KeyBind = content.KeyBind; getPosition = getPosition or KEYBIND_GETPOSITION; local function updateKeybind(customtext) if customtext then KeyBind.Text = customtext; else KeyBind.Text = "[" .. ((KeyBindKey and KeyBindKey.Name) or "NONE") .. "]"; end; KeyBind.Size = UDim2.new(0, KeyBind.TextBounds.X + 10, 1, -6); KeyBind.Position = getPosition(KeyBind); end; updateKeybind(); ConfigChangedSignals[Key]:Connect(function(new, ignore) KeyBindKey = new; if ignore then return; end; updateKeybind(); end); if callback then table.insert(Shared.Connections, INPUT_BEGAN:Connect(function(Input, GPE) if GPE then return; end; local KeyCode, UserInputType = Input.KeyCode, Input.UserInputType; if KeyCode ~= KeyBindKey and UserInputType ~= KeyBindKey then return; end; callback(); end)); end; KeyBind.MouseButton1Click:Connect(function() updateKeybind("[...]"); local ACTION_NAME = Key .. "_ACTION"; CONTEXT_ACTION_SERVICE:BindCoreAction(ACTION_NAME, function(action_name, input_state, input) if action_name ~= ACTION_NAME or input_state ~= BEGIN then return PASS; end; local new = getKeyFromInput(input); if not new then return PASS; end; if new == KEYCODE_ESCAPE then new = nil; end; Config:set(Key, new); CONTEXT_ACTION_SERVICE:UnbindCoreAction(ACTION_NAME); table.remove(Shared.Actions, table.find(Shared.Actions, ACTION_NAME)); end, false, unpack(ContextWhitelist)); table.insert(Shared.Actions, ACTION_NAME); end); return element; end; local function TOGGLE_GETPOSITION(KeyBind) return UDim2.new(1, -21 - KeyBind.Size.X.Offset - 10, 0, 3); end; local function addToggle(Key, KeyBindKey) local Value = Config:get(Key); local element = ToggleTemplate:Clone(); element.Name = Key; element.Parent = ConfigContainer; local content = element.Content; content.Label.Text = Key; local Display = content.Display; Display.BackgroundColor3 = (Value and OnColor) or OffColor; local DisplayTween; local NewDisplayTween; ConfigChangedSignals[Key]:Connect(function(new) local old = Value; Value = new; if Value == old then return; end; if DisplayTween then DisplayTween:Pause(); Display.Position = UDim2.new(1, -21, 0, 8); DisplayTween = nil; end; if NewDisplayTween then NewDisplayTween:Pause(); NewDisplayTween.Instance:Destroy(); NewDisplayTween = nil; end; local NewDisplay = Display:Clone(); Display.Position = UDim2.new(1, -21 - 14, 0, 8); Display.BackgroundColor3 = (new and OnColor) or OffColor; NewDisplay.Parent = content; local displaytween = Tween.PlayNew(Display, ButtonAnimationsTInfo, {Position = UDim2.new(1, -21, 0, 8)}); displaytween.Completed:Once(function() if NewDisplay.Parent then NewDisplay:Destroy(); end; if DisplayTween == displaytween then DisplayTween = nil; end; end); DisplayTween = displaytween; local newdisplaytween = Tween.PlayNew(NewDisplay, ButtonAnimationsTInfo, {Position = UDim2.new(1, 6, 0, 8)}); newdisplaytween.Completed:Once(function() if NewDisplayTween == newdisplaytween then NewDisplayTween = nil; end; end); NewDisplayTween = newdisplaytween; end); local function toggle() Config:set(Key, not Config:get(Key)); end; element.MouseButton1Click:Connect(toggle); setupButtonAnimations(element, content, closeRightClickMenu); addKeyBind(Key .. "_KEYBIND", KeyBindKey, element, toggle, TOGGLE_GETPOSITION); return element; end; local function addText(Key)  local Value = Config:get(Key); local element = TextTemplate:Clone(); element.Name = Key; element.Label.Text = Key; element.Parent = ConfigContainer; local box = element.Box; local BoxPropertyName = (Config:get("TEXT_USE_PLACEHOLDER_TEXT") and "PlaceholderText") or "Text"; TextUsePlaceholderText:Connect(function(useplaceholdertext) BoxPropertyName = (useplaceholdertext and "PlaceholderText") or "Text"; if useplaceholdertext then box.Text = ""; box.PlaceholderText = tostring(Value); else box.Text = tostring(Value); box.PlaceholderText = DefaultsLookup[Key] or Key; end; end); box[BoxPropertyName] = tostring(Value); ConfigChangedSignals[Key]:Connect(function(new) Value = new; box[BoxPropertyName] = Value; end); box.FocusLost:Connect(function(EnterPressed) local Text = box.Text; if (not EnterPressed) then box.Text = "";  box[BoxPropertyName] = Value; return; end; Config:set(Key, Text); if BoxPropertyName == "PlaceholderText" then box.Text = ""; end; end); return element; end; local function addSlider(Key, min, max) local places = #(tostring(min):gsub(".+%.", "")); local Value = Config:get(Key); local Element = SliderTemplate:Clone(); Element.Name = Key; Element.Parent = ConfigContainer; local Content = Element.Content; Content.Label.Text = Key; local Display = Content.Display; local SlideContainer = Content.SlideContainer; local Slide = SlideContainer.Slide; local function updateValue() Display.Text = Value .. " / " .. max; Tween.PlayNew(Slide, ButtonAnimationsTInfo, {Size = UDim2.new(mathmap(Value, min, max, 0, 1), 0, 0, 20)}); end; updateValue(); ConfigChangedSignals[Key]:Connect(function(new) Value = new; updateValue(); end); local SlideContainerAbsoluteSizeX = SlideContainer.AbsoluteSize.X; dragObject(SlideContainer, function(Position) local SlideContainerAbsolutePositionX = SlideContainer.AbsolutePosition.X; local SlidePosition = math.clamp(Position.X - SlideContainerAbsolutePositionX, 0, SlideContainerAbsoluteSizeX); local mapped = mathmap(SlidePosition, 0, SlideContainerAbsoluteSizeX, min, max); Value = mathround(mapped, places);       Config:set(Key, Value); end); return Element; end; local function addColor(Key, InitialValue) local Color = Config:get(Key) or InitialValue; local element = ColorTemplate:Clone(); element.Label.Text = Key; element.Name = Key; element.Parent = ConfigContainer; local Display = element.Display; local HueFrame = element.Hue; local Square = element.Square; local SquareGradient = Square.UIGradient; local Hue, Saturation, Value = Color:ToHSV(); local SliderHue = Hue; local function updateColor() Color = Color3.fromHSV(Hue, Saturation, Value); Display.BackgroundColor3 = Color; end; local function updateGradient() SquareGradient.Color = ColorSequence.new(Constants.WHITE, Color3.fromHSV(SliderHue, 1, 1)); end; local updateCursors; updateColor(); updateGradient();  ConfigChangedSignals[Key]:Connect(function(new, cursors, reset) local oldnew = new; if not oldnew then new = Constants.WHITE; end; local NewHue; NewHue, Saturation, Value = new:ToHSV(); if cursors then if reset then SliderHue = NewHue; end; updateCursors(); end; updateColor(); updateGradient(); end); local function setColor(cursors) updateColor(); Config:set(Key, Color, cursors); end; local HueFrameArrow = HueFrame.Arrow; local HueFrameAbsoluteSizeY = HueFrame.AbsoluteSize.Y; local HueFrameArrowOffset = -5; dragObject(HueFrame, function(Position) local AbsolutePositionY = HueFrame.AbsolutePosition.Y;  local ArrowPosition = math.clamp(Position.Y - AbsolutePositionY, 0, HueFrameAbsoluteSizeY) + HueFrameArrowOffset; HueFrameArrow.Position = UDim2.new(1, 0, 0, ArrowPosition); Hue = math.abs(math.round(mathmap(ArrowPosition, 0 + HueFrameArrowOffset, HueFrameAbsoluteSizeY + HueFrameArrowOffset, 0, 100))) / 100; SliderHue = Hue; setColor(true); end); local SquareCircle = Square.Circle; local CircleSizeHalved = SquareCircle.Size.Y.Offset / 2; local SquareAbsoluteSizeY = Square.AbsoluteSize.Y; local SquareAbsoluteSizeX = Square.AbsoluteSize.X; dragObject(Square, function(Position) local AbsolutePositionY = Square.AbsolutePosition.Y;  local AbsolutePositionX = Square.AbsolutePosition.X;  local CirclePositionX = math.clamp(Position.X - AbsolutePositionX, 0, SquareAbsoluteSizeX); local CirclePositionY = math.clamp(Position.Y - AbsolutePositionY, 0, SquareAbsoluteSizeY); SquareCircle.Position = UDim2.fromOffset(CirclePositionX - CircleSizeHalved, CirclePositionY - CircleSizeHalved); Saturation = mathmap(CirclePositionX, 0, SquareAbsoluteSizeX, 0, 1); Value = mathmap(CirclePositionY, 0, SquareAbsoluteSizeY, 1, 0); setColor(true); end); updateCursors = function() local HueFrameArrowPosition = SliderHue; HueFrameArrowPosition *= 100; HueFrameArrowPosition = mathmap(HueFrameArrowPosition, 0, 100, 0 + HueFrameArrowOffset, HueFrameAbsoluteSizeY + HueFrameArrowOffset); HueFrameArrow.Position = UDim2.new(1, 0, 0, HueFrameArrowPosition); local CirclePositionX = Saturation; local CirclePositionY = Value; CirclePositionX = mathmap(CirclePositionX, 0, 1, 0, SquareAbsoluteSizeX); CirclePositionY = mathmap(CirclePositionY, 1, 0, 0, SquareAbsoluteSizeY); SquareCircle.Position = UDim2.fromOffset(CirclePositionX - CircleSizeHalved, CirclePositionY - CircleSizeHalved); end; updateCursors(); return element; end; local function convert(value, desiredtype) local valuetype = type(value); if valuetype == desiredtype then return value; end; if desiredtype == "number" then return tonumber(value); elseif desiredtype == "string" then return tostring(value); elseif desiredtype == "Vector3" then return Vector3.new(value.X, value.Y, value.Z); elseif desiredtype == "Vector2" then warn("ADD VECTOR2 SUPPORT [@convert]"); end; end; local function toTable(value, info) local result = {}; if value then for _, name in next, info do result[name] = value[name]; end; end; return result; end; local function addStruct(Key, StructInfo, Type) local Value = toTable(Config:get(Key), StructInfo); local element = StructTemplate:Clone(); element.Name = Key; element.Label.Text = Key; element.Parent = ConfigContainer; element.Size = UDim2.new(1, 0, 0, 24); local boxes = {}; local BoxPropertyName = (Config:get("STRUCT_USE_PLACEHOLDER_TEXT") and "PlaceholderText") or "Text"; StructUsePlaceholderText:Connect(function(useplaceholdertext) BoxPropertyName = (useplaceholdertext and "PlaceholderText") or "Text"; for name, box in next, boxes do if useplaceholdertext then box.Text = ""; box.PlaceholderText = tostring(Value[name]); else box.Text = tostring(Value[name]); box.PlaceholderText = (DefaultsLookup[Key] and DefaultsLookup[Key][name]) or Key; end; end; end); ConfigChangedSignals[Key]:Connect(function(new) Value = toTable(new, StructInfo); for name, box in next, boxes do box[BoxPropertyName] = tostring(Value[name]); end; end); local bottom = element.Bottom; for _, name in next, StructInfo do local value_element = StructValueTemplate:Clone(); value_element.Parent = bottom; value_element.ValueName.Text = name; local box = value_element.Box; box[BoxPropertyName] = tostring(Value[name]); box.FocusLost:Connect(function(EnterPressed) local Text = box.Text; if not EnterPressed then box.Text = ""; box[BoxPropertyName] = tostring(Value[name]); return; end; local new = convert(Text, type(Value[name])); if type(new) ~= "nil" then Value[name] = new; Config:set(Key, convert(Value, Type)); end; if BoxPropertyName == "PlaceholderText" then box.Text = ""; end; end); boxes[name] = box; end; element.Size += UDim2.fromOffset(0, 10 + (#StructInfo * 16)); return element; end; local function addDropdown(Key, DropdownInfo) local InitialValue = Config:get(Key); local element = DropdownTemplate:Clone(); element.Name = Key; element.Label.Text = Key; element.Parent = ConfigContainer; element.Size = UDim2.new(1, 0, 0, 40); local selected = element.SelectedLabel; selected.Text = InitialValue;  local click_connections = {}; ConfigChangedSignals[Key]:Connect(function(new) selected.Text = new; for option_element, connection in next, click_connections do local option = option_element.Name; if connection then connection:Disconnect(); end; if option == new then click_connections[option_element] = false; continue; end; click_connections[option_element] = option_element.MouseButton1Click:Connect(function() Config:set(Key, option); end); end; end); local bottom = element.Bottom; for _, option in next, DropdownInfo do local option_element = DropdownOptionTemplate:Clone(); option_element.Name = option; option_element.Parent = bottom; option_element.Label.Text = option; if option == InitialValue then click_connections[option_element] = false; continue; end; click_connections[option_element] = option_element.MouseButton1Click:Connect(function() Config:set(Key, option); end); end; element.Size += UDim2.fromOffset(0, 10 + (#DropdownInfo * 16)); return element; end; local function addSeparator(Name) local element = SeparatorTemplate:Clone(); element.Name = Name; element.Text = Name; element.Parent = ConfigContainer; return element; end; local ElementToKeyMap = {}; local function onRightClick(obj, callback) local isMouseOver = false; local canClick = true; obj.InputBegan:Connect(function(Input) if Input.UserInputType == Constants.MOUSEMOVEMENT then isMouseOver = true; elseif Input.UserInputType == Constants.MOUSEBUTTON2 then canClick = true; end; end); obj.InputEnded:Connect(function(Input) if Input.UserInputType == Constants.MOUSEMOVEMENT then isMouseOver = false; canClick = false; elseif Input.UserInputType == Constants.MOUSEBUTTON2 then if not (isMouseOver and canClick) then return; end; callback(Input.Position); end; end); end; local Vector3StructInfo = { "X", "Y", "Z"}; local Vector3YONLYStructInfo = { "Y"}; for Index, Pair in next, InitialValues do if UISections[Index] then addSeparator(UISections[Index]); end; local Key, Value, DropdownOptions, range = Pair[1], Pair[2], Pair.dropdownoptions, Pair.range; local element; local Type = typeof(Value); if DropdownOptions then element = addDropdown(Key, DropdownOptions); else if Type == "boolean" then element = addToggle(Key, Config:get(Key .. "_KEYBIND")); elseif Type == "number" then if range then element = addSlider(Key, range.min, range.max); else warn("NO RANGE FOUND FOR NUMBER " .. Key .. " USE :defaultSlider FOR NUMBERS"); end; elseif Type == "Color3" then element = addColor(Key, Value); elseif Type == "Vector2" then warn("ADD VECTOR2 SUPPORT [@'for Index, Pair in next, InitialValues']"); elseif Type == "Vector3" then element = addStruct(Key, (Key:find("VERTICAL_OFFSET") and Vector3YONLYStructInfo) or Vector3StructInfo, "Vector3"); elseif Type == "EnumItem" then element = addKeyBind(Key, Value); else element = addText(Key); end; end; if not element then warn("NO ELEMENT CREATED FOR '" .. Key .. "' [" .. Type .. "]"); end; ElementToKeyMap[element] = Key; onRightClick(element, function(Position) Position += Constants.RIGHT_CLICK_MENU_OFFSET; RightClickMenu.Position = UDim2.fromOffset(Position.X - MainFrame.AbsolutePosition.X, Position.Y - MainFrame.AbsolutePosition.Y); RightClickedElement = element; RightClickMenu.Visible = true; end); end; ConfigContainer.CanvasSize = UDim2.fromOffset(0, ConfigContainerListLayout.AbsoluteContentSize.Y); RightClickMenu.ResetToDefault.MouseButton1Click:Connect(function() local Key = ElementToKeyMap[RightClickedElement]; Config:set(Key, DefaultsLookup[Key], true, true); closeRightClickMenu(); end); INPUT_BEGAN:Connect(function(Input, GameProccessed) if GameProccessed or Input.UserInputType ~= MOUSEBUTTON1 then return; end; closeRightClickMenu(); end); return ScreenGui;
end;
ModuleExports["ui"] = f_module_ui;
local function f_module_ui_ui()
local function _New_(a)local b=a[1];table.remove(a,1);local c=Instance.new(b);local d=a[1];if d then c.Parent=d;table.remove(a,1);end;for K,V in next,a do c[K]=V;end;return c;end; local UniversalAimbotAndEspV2 = _New_{"ScreenGui", game:GetService("CoreGui"),	Name = "UniversalAimbotAndEspV2",	ResetOnSpawn = false,	ZIndexBehavior = Enum.ZIndexBehavior.Sibling,}; local MainFrame = _New_{"Frame", UniversalAimbotAndEspV2,	BackgroundColor3 = Color3.fromRGB(44.000001177191734, 44.000001177191734, 44.000001177191734),	BorderSizePixel = 0,	Name = "MainFrame",	Position = UDim2.new(0.41697829961776733, -370, 0.5, -275),	Size = UDim2.new(0, 460, 0, 550),}; local Panels = _New_{"Frame", MainFrame,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Panels",	Position = UDim2.new(0, 0, 0, 34),	Size = UDim2.new(1, 0, 1, -34),}; local ConfigPanel = _New_{"Frame", Panels,	BackgroundColor3 = Color3.fromRGB(66.00000366568565, 66.00000366568565, 66.00000366568565),	BorderSizePixel = 0,	Name = "ConfigPanel",	Position = UDim2.new(0, 10, 0, 0),	Size = UDim2.new(1, -20, 1, -10),}; local Container = _New_{"ScrollingFrame", ConfigPanel,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Container",	Position = UDim2.new(0, 6, 0, 6),	Selectable = false,	Size = UDim2.new(1, -12, 1, -12),	AutomaticCanvasSize = Enum.AutomaticSize.Y,	CanvasSize = UDim2.new(0, 0, 0, 0),	ScrollBarThickness = 6,	VerticalScrollBarInset = Enum.ScrollBarInset.Always,}; local Separator = _New_{"TextLabel", Container,	BackgroundColor3 = Color3.fromRGB(52.00000450015068, 52.00000450015068, 52.00000450015068),	BorderSizePixel = 0,	Name = "Separator",	Size = UDim2.new(1, 0, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Separator",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextYAlignment = Enum.TextYAlignment.Top,}; local Line = _New_{"Frame", Separator,	BackgroundColor3 = Color3.fromRGB(200.00001847743988, 200.00001847743988, 200.00001847743988),	Name = "Line",	Position = UDim2.new(0, 0, 1, -2),	Size = UDim2.new(1, 0, 0, 2),}; local UICorner = _New_{"UICorner", Separator,	CornerRadius = UDim.new(0, 4),}; local Text = _New_{"Frame", Container,	BackgroundColor3 = Color3.fromRGB(52.00000450015068, 52.00000450015068, 52.00000450015068),	BorderSizePixel = 0,	Name = "Text",	Size = UDim2.new(1, 0, 0, 46),}; local Label = _New_{"TextLabel", Text,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 6, 0, 0),	Size = UDim2.new(1, -6, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Text",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextXAlignment = Enum.TextXAlignment.Left,}; local Box = _New_{"TextBox", Text,	BackgroundColor3 = Color3.fromRGB(42.000001296401024, 42.000001296401024, 42.000001296401024),	BorderSizePixel = 0,	ClearTextOnFocus = false,	Name = "Box",	Position = UDim2.new(0, 6, 1, -22),	Size = UDim2.new(1, -12, 0, 16),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	PlaceholderText = "Value",	Text = "",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 14,}; local UICorner_0 = _New_{"UICorner", Text,	CornerRadius = UDim.new(0, 4),}; local Color = _New_{"Frame", Container,	BackgroundColor3 = Color3.fromRGB(52.00000450015068, 52.00000450015068, 52.00000450015068),	BorderSizePixel = 0,	Name = "Color",	Size = UDim2.new(1, 0, 0, 112),}; local Square = _New_{"Frame", Color,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 0.10000000149011612,	BorderColor3 = Color3.fromRGB(0, 0, 0),	BorderSizePixel = 3,	Name = "Square",	Position = UDim2.new(0.5, -58, 0, 26),	Size = UDim2.new(0, 78, 0, 78),}; local UIGradient = _New_{"UIGradient", Square,	Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))},}; local DownUp = _New_{"Frame", Square,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BorderSizePixel = 0,	Name = "DownUp",	Position = UDim2.new(0, 0, -1.307692289352417, 0),	Size = UDim2.new(1, 0, 2.307692289352417, 0),}; local UIGradient_0 = _New_{"UIGradient", DownUp,	Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))},	Rotation = 90,	Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 1, 0), NumberSequenceKeypoint.new(0.6000000238418579, 1, 0), NumberSequenceKeypoint.new(1, 0, 0)},}; local UICorner_1 = _New_{"UICorner", DownUp,	CornerRadius = UDim.new(0, 4),}; local Circle = _New_{"Frame", Square,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 0.6000000238418579,	BorderSizePixel = 0,	Name = "Circle",	Position = UDim2.new(1, -8, 0, -8),	Size = UDim2.new(0, 16, 0, 16),}; local UICorner_2 = _New_{"UICorner", Circle,	CornerRadius = UDim.new(1, 0),}; local UIStroke = _New_{"UIStroke", Circle,	Thickness = 2,}; local UICorner_3 = _New_{"UICorner", Square,	CornerRadius = UDim.new(0, 4),}; local Hue = _New_{"Frame", Color,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BorderColor3 = Color3.fromRGB(0, 0, 0),	BorderSizePixel = 3,	Name = "Hue",	Position = UDim2.new(0.5, 30, 0, 26),	Size = UDim2.new(0, 14, 0, 78),}; local UIGradient_1 = _New_{"UIGradient", Hue,	Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 4.000000236555934)), ColorSequenceKeypoint.new(0.25, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(0.375432550907135, Color3.fromRGB(0, 255, 0)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)), ColorSequenceKeypoint.new(0.6245675086975098, Color3.fromRGB(0, 0, 255)), ColorSequenceKeypoint.new(0.75, Color3.fromRGB(127.00000002980232, 0, 255)), ColorSequenceKeypoint.new(0.875432550907135, Color3.fromRGB(255, 0, 255)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))},	Rotation = 90,}; local Arrow = _New_{"TextLabel", Hue,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Arrow",	Position = UDim2.new(1, 0, 0, -5),	Size = UDim2.new(0, 10, 0, 10),	Font = Enum.Font.Unknown,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal),	Text = "<",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 20,	TextWrapped = true,}; local UICorner_4 = _New_{"UICorner", Hue,	CornerRadius = UDim.new(0, 4),}; local Display = _New_{"Frame", Color,	BackgroundColor3 = Color3.fromRGB(255, 0, 0),	BorderSizePixel = 0,	Name = "Display",	Position = UDim2.new(1, -21, 0, 8),	Size = UDim2.new(0, 14, 0, 8),}; local UICorner_5 = _New_{"UICorner", Display,	CornerRadius = UDim.new(0, 3),}; local Label_0 = _New_{"TextLabel", Color,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 6, 0, 0),	Size = UDim2.new(1, -41, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Color",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextXAlignment = Enum.TextXAlignment.Left,}; local UICorner_6 = _New_{"UICorner", Color,	CornerRadius = UDim.new(0, 4),}; local Toggle = _New_{"TextButton", Container,	Active = false,	AutoButtonColor = false,	BackgroundColor3 = Color3.fromRGB(52.000000700354576, 52.000000700354576, 52.000000700354576),	BorderSizePixel = 0,	Name = "Toggle",	Selectable = false,	Size = UDim2.new(1, 0, 0, 30),	ClipsDescendants = true,	Text = "",}; local Content = _New_{"Frame", Toggle,	BackgroundColor3 = Color3.fromRGB(58.00000034272671, 58.00000034272671, 58.00000034272671),	BorderSizePixel = 0,	Name = "Content",	Position = UDim2.new(0, 5, 0, 5),	Size = UDim2.new(1, -10, 1, -10),	ClipsDescendants = true,}; local Label_1 = _New_{"TextLabel", Content,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 6, 0, 0),	Size = UDim2.new(1, -35, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Toggle",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextXAlignment = Enum.TextXAlignment.Left,	TextYAlignment = Enum.TextYAlignment.Top,}; local Display_0 = _New_{"Frame", Content,	BackgroundColor3 = Color3.fromRGB(210.00000268220901, 58.00000034272671, 58.00000034272671),	BorderSizePixel = 0,	Name = "Display",	Position = UDim2.new(1, -21, 0, 6),	Size = UDim2.new(0, 14, 1, -12),}; local UICorner_7 = _New_{"UICorner", Display_0,	CornerRadius = UDim.new(0, 3),}; local UICorner_8 = _New_{"UICorner", Content,	CornerRadius = UDim.new(0, 4),}; local KeyBind = _New_{"TextButton", Content,	BackgroundColor3 = Color3.fromRGB(72.00000330805779, 72.00000330805779, 72.00000330805779),	Name = "KeyBind",	Position = UDim2.new(1, -96, 0, 3),	Size = UDim2.new(0, 70, 1, -6),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "[LeftShift]",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 14,}; local UICorner_9 = _New_{"UICorner", KeyBind,	CornerRadius = UDim.new(0, 4),}; local UICorner_10 = _New_{"UICorner", Toggle,	CornerRadius = UDim.new(0, 4),}; local Struct = _New_{"Frame", Container,	BackgroundColor3 = Color3.fromRGB(52.00000450015068, 52.00000450015068, 52.00000450015068),	BorderSizePixel = 0,	Name = "Struct",	Position = UDim2.new(0, 0, 0.46000000834465027, 0),	Size = UDim2.new(1, 0, 0, 50),}; local Label_2 = _New_{"TextLabel", Struct,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 6, 0, 0),	Size = UDim2.new(1, -6, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Struct",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextXAlignment = Enum.TextXAlignment.Left,}; local Bottom = _New_{"Frame", Struct,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Bottom",	Position = UDim2.new(0, 6, 0, 27),	Size = UDim2.new(1, -12, 0, 16),}; local Value = _New_{"Frame", Bottom,	Active = true,	BackgroundColor3 = Color3.fromRGB(42.000001296401024, 42.000001296401024, 42.000001296401024),	BorderSizePixel = 0,	Name = "Value",	Selectable = true,	Size = UDim2.new(1, 0, 0, 16),}; local Box_0 = _New_{"TextBox", Value,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	ClearTextOnFocus = false,	Name = "Box",	Position = UDim2.new(0.5, -50, 0, 0),	Size = UDim2.new(0.5, 50, 1, 0),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	PlaceholderText = "Value",	Text = "",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 14,	TextXAlignment = Enum.TextXAlignment.Left,}; local ValueName = _New_{"TextLabel", Value,	Active = true,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "ValueName",	Position = UDim2.new(0, 6, 0, 0),	Selectable = true,	Size = UDim2.new(0.5, -56, 1, 0),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Value Name",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 14,	TextXAlignment = Enum.TextXAlignment.Left,}; local UICorner_11 = _New_{"UICorner", Value,	CornerRadius = UDim.new(0, 4),}; local UIListLayout = _New_{"UIListLayout", Bottom,	SortOrder = Enum.SortOrder.LayoutOrder,}; local UICorner_12 = _New_{"UICorner", Struct,	CornerRadius = UDim.new(0, 4),}; local Dropdown = _New_{"Frame", Container,	BackgroundColor3 = Color3.fromRGB(52.00000450015068, 52.00000450015068, 52.00000450015068),	BorderSizePixel = 0,	Name = "Dropdown",	Position = UDim2.new(0, 0, 0.46000000834465027, 0),	Size = UDim2.new(1, 0, 0, 63),}; local Label_3 = _New_{"TextLabel", Dropdown,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 6, 0, 0),	Size = UDim2.new(1, -6, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Dropdown",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextXAlignment = Enum.TextXAlignment.Left,}; local Bottom_0 = _New_{"Frame", Dropdown,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Bottom",	Position = UDim2.new(0, 6, 0, 39),	Size = UDim2.new(1, -12, 0, 16),}; local UIListLayout_0 = _New_{"UIListLayout", Bottom_0,	SortOrder = Enum.SortOrder.LayoutOrder,}; local Template = _New_{"TextButton", Bottom_0,	BackgroundColor3 = Color3.fromRGB(42.000001296401024, 42.000001296401024, 42.000001296401024),	BorderSizePixel = 0,	Name = "Template",	Size = UDim2.new(1, 0, 0, 16),	Text = "",}; local Label_4 = _New_{"TextLabel", Template,	Active = true,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 6, 0, 0),	Selectable = true,	Size = UDim2.new(1, -6, 1, 0),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Option Name",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 14,	TextXAlignment = Enum.TextXAlignment.Left,}; local UICorner_13 = _New_{"UICorner", Template,	CornerRadius = UDim.new(0, 4),}; local SelectedLabel = _New_{"TextLabel", Dropdown,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "SelectedLabel",	Position = UDim2.new(0, 6, 0, 18),	Size = UDim2.new(1, -6, 0, 18),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Selected",	TextColor3 = Color3.fromRGB(222.0000171661377, 222.0000171661377, 222.0000171661377),	TextSize = 16,	TextXAlignment = Enum.TextXAlignment.Left,}; local UICorner_14 = _New_{"UICorner", Dropdown,	CornerRadius = UDim.new(0, 4),}; local Section = _New_{"Frame", Container,	BackgroundColor3 = Color3.fromRGB(52.000000700354576, 52.000000700354576, 52.000000700354576),	BorderSizePixel = 0,	Name = "Section",	Size = UDim2.new(1, 0, 0, 24),	Visible = false,}; local Separator_0 = _New_{"TextLabel", Section,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Separator",	Size = UDim2.new(1, 0, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Separator",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextYAlignment = Enum.TextYAlignment.Top,}; local Line_0 = _New_{"Frame", Separator_0,	BackgroundColor3 = Color3.fromRGB(200.00001847743988, 200.00001847743988, 200.00001847743988),	BorderSizePixel = 0,	Name = "Line",	Position = UDim2.new(0, 4, 1, -2),	Size = UDim2.new(1, -8, 0, 2),}; local UICorner_15 = _New_{"UICorner", Section,	CornerRadius = UDim.new(0, 4),}; local UIListLayout_1 = _New_{"UIListLayout", Container,	Padding = UDim.new(0, 5),	SortOrder = Enum.SortOrder.LayoutOrder,}; local KeyBind_0 = _New_{"Frame", Container,	BackgroundColor3 = Color3.fromRGB(52.00000450015068, 52.00000450015068, 52.00000450015068),	BorderSizePixel = 0,	Name = "KeyBind",	Size = UDim2.new(1, 0, 0, 30),}; local UICorner_16 = _New_{"UICorner", KeyBind_0,	CornerRadius = UDim.new(0, 4),}; local Content_0 = _New_{"Frame", KeyBind_0,	BackgroundColor3 = Color3.fromRGB(58.00000414252281, 58.00000414252281, 58.00000414252281),	BorderSizePixel = 0,	Name = "Content",	Position = UDim2.new(0, 5, 0, 5),	Size = UDim2.new(1, -10, 1, -10),	ClipsDescendants = true,}; local Label_5 = _New_{"TextLabel", Content_0,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 6, 0, 0),	Size = UDim2.new(1, -35, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "KeyBind",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextXAlignment = Enum.TextXAlignment.Left,	TextYAlignment = Enum.TextYAlignment.Top,}; local UICorner_17 = _New_{"UICorner", Content_0,	CornerRadius = UDim.new(0, 4),}; local KeyBind_1 = _New_{"TextButton", Content_0,	BackgroundColor3 = Color3.fromRGB(72.00000330805779, 72.00000330805779, 72.00000330805779),	Name = "KeyBind",	Position = UDim2.new(1, -75, 0, 3),	Size = UDim2.new(0, 70, 1, -6),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "[LeftShift]",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 14,}; local UICorner_18 = _New_{"UICorner", KeyBind_1,	CornerRadius = UDim.new(0, 4),}; local Slider = _New_{"Frame", Container,	BackgroundColor3 = Color3.fromRGB(52.00000450015068, 52.00000450015068, 52.00000450015068),	BorderSizePixel = 0,	Name = "Slider",	Size = UDim2.new(1, 0, 0, 66),}; local UICorner_19 = _New_{"UICorner", Slider,	CornerRadius = UDim.new(0, 4),}; local Content_1 = _New_{"Frame", Slider,	BackgroundColor3 = Color3.fromRGB(58.00000034272671, 58.00000034272671, 58.00000034272671),	BorderSizePixel = 0,	Name = "Content",	Position = UDim2.new(0, 5, 0, 5),	Size = UDim2.new(1, -10, 1, -10),}; local Label_6 = _New_{"TextLabel", Content_1,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 6, 0, 0),	Size = UDim2.new(1, -6, 0, 24),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Slider",	TextColor3 = Color3.fromRGB(255, 255, 255223.99658203125),	TextSize = 20,	TextXAlignment = Enum.TextXAlignment.Left,}; local SlideContainer = _New_{"Frame", Content_1,	BackgroundColor3 = Color3.fromRGB(66.00000366568565, 66.00000366568565, 66.00000366568565),	BorderSizePixel = 0,	Name = "SlideContainer",	Position = UDim2.new(0, 10, 0, 35),	Size = UDim2.new(1, -20, 0, 16),}; local UICorner_20 = _New_{"UICorner", SlideContainer,	CornerRadius = UDim.new(0, 4),}; local Slide = _New_{"Frame", SlideContainer,	BackgroundColor3 = Color3.fromRGB(80.00000283122063, 80.00000283122063, 80.00000283122063),	BorderSizePixel = 0,	Name = "Slide",	Position = UDim2.new(0, 0, 0.5, -10),	Size = UDim2.new(0, 20, 0, 20),}; local UICorner_21 = _New_{"UICorner", Slide,	CornerRadius = UDim.new(0, 4),}; local UICorner_22 = _New_{"UICorner", Content_1,	CornerRadius = UDim.new(0, 4),}; local Display_1 = _New_{"TextLabel", Content_1,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Display",	Position = UDim2.new(0, 6, 0, 20),	Size = UDim2.new(1, -6, 0, 14),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "0 / 100",	TextColor3 = Color3.fromRGB(180.00000447034836, 180.00000447034836, 180.00000447034836),	TextSize = 14,}; local UICorner_23 = _New_{"UICorner", ConfigPanel,	CornerRadius = UDim.new(0, 4),}; local TopBar = _New_{"Frame", MainFrame,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "TopBar",	Size = UDim2.new(1, 0, 0, 32),}; local Title = _New_{"TextLabel", TopBar,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Title",	Position = UDim2.new(0, 6, 0, 0),	Size = UDim2.new(0, 194, 1, 0),	Font = Enum.Font.Unknown,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal),	Text = "Universal Aimbot N Esp",	TextColor3 = Color3.fromRGB(224.000001847744, 224.000001847744, 224.000001847744),	TextSize = 22,}; local Credits = _New_{"TextLabel", Title,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Credits",	Position = UDim2.new(1, 4, 0, 0),	Size = UDim2.new(0, 148, 1, 0),	Font = Enum.Font.Unknown,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.SemiBold, Enum.FontStyle.Normal),	Text = "Made by TechHog#8984",	TextColor3 = Color3.fromRGB(180.00000447034836, 180.00000447034836, 180.00000447034836),	TextSize = 16,	TextXAlignment = Enum.TextXAlignment.Left,}; local CloseOLD = _New_{"TextButton", TopBar,	AutoButtonColor = false,	BackgroundColor3 = Color3.fromRGB(190.0000038743019, 52.000000700354576, 52.000000700354576),	BorderSizePixel = 0,	Name = "CloseOLD",	Position = UDim2.new(1, -28, 0, 4),	Size = UDim2.new(0, 20, 1, -8),	Visible = false,	Font = Enum.Font.SourceSans,	FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "",	TextColor3 = Color3.fromRGB(0, 0, 0),	TextSize = 14,}; local UICorner_24 = _New_{"UICorner", CloseOLD,	CornerRadius = UDim.new(0, 4),}; local Frame = _New_{"Frame", CloseOLD,	BackgroundColor3 = Color3.fromRGB(240.0000160932541, 66.00000366568565, 66.00000366568565),	Position = UDim2.new(0, 3, 0, 3),	Size = UDim2.new(1, -6, 1, -6),}; local UICorner_25 = _New_{"UICorner", Frame,	CornerRadius = UDim.new(0, 4),}; local MinimizeOLD = _New_{"TextButton", TopBar,	AutoButtonColor = false,	BackgroundColor3 = Color3.fromRGB(197.00001865625381, 182.00000435113907, 49.000004678964615),	BorderSizePixel = 0,	Name = "MinimizeOLD",	Position = UDim2.new(1, -56, 0, 4),	Size = UDim2.new(0, 20, 1, -8),	Visible = false,	Font = Enum.Font.SourceSans,	FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "",	TextColor3 = Color3.fromRGB(0, 0, 0),	TextSize = 14,}; local UICorner_26 = _New_{"UICorner", MinimizeOLD,	CornerRadius = UDim.new(0, 4),}; local Frame_0 = _New_{"Frame", MinimizeOLD,	BackgroundColor3 = Color3.fromRGB(240.00000089406967, 200.00000327825546, 58.00000034272671),	Position = UDim2.new(0, 3, 0, 3),	Size = UDim2.new(1, -6, 1, -6),}; local UICorner_27 = _New_{"UICorner", Frame_0,	CornerRadius = UDim.new(0, 4),}; local ResetAll = _New_{"TextButton", TopBar,	AutoButtonColor = false,	BackgroundColor3 = Color3.fromRGB(74.0000031888485, 74.0000031888485, 74.0000031888485),	BorderSizePixel = 0,	Name = "ResetAll",	Position = UDim2.new(1, -121, 0.5, -9),	Size = UDim2.new(0, 58, 0, 18),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "",	TextColor3 = Color3.fromRGB(210.00001788139343, 210.00001788139343, 210.00001788139343),	TextSize = 14,}; local UICorner_28 = _New_{"UICorner", ResetAll,	CornerRadius = UDim.new(0, 4),}; local Label_7 = _New_{"TextLabel", ResetAll,	BackgroundColor3 = Color3.fromRGB(88.00000235438347, 88.00000235438347, 88.00000235438347),	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 3, 0, 3),	Size = UDim2.new(1, -6, 1, -6),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Reset All",	TextColor3 = Color3.fromRGB(210.00001788139343, 210.00001788139343, 210.00001788139343),	TextSize = 14,}; local UICorner_29 = _New_{"UICorner", Label_7,	CornerRadius = UDim.new(0, 4),}; local Minimize = _New_{"TextButton", TopBar,	AutoButtonColor = false,	BackgroundColor3 = Color3.fromRGB(74.0000031888485, 74.0000031888485, 74.0000031888485),	BorderSizePixel = 0,	Name = "Minimize",	Position = UDim2.new(1, -56, 0, 4),	Size = UDim2.new(0, 20, 1, -8),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "",	TextColor3 = Color3.fromRGB(210.00001788139343, 210.00001788139343, 210.00001788139343),	TextSize = 14,}; local UICorner_30 = _New_{"UICorner", Minimize,	CornerRadius = UDim.new(0, 4),}; local Label_8 = _New_{"TextLabel", Minimize,	BackgroundColor3 = Color3.fromRGB(88.00000235438347, 88.00000235438347, 88.00000235438347),	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 3, 0, 3),	Size = UDim2.new(1, -6, 1, -6),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "-",	TextColor3 = Color3.fromRGB(210.00001788139343, 210.00001788139343, 210.00001788139343),	TextSize = 20,}; local UICorner_31 = _New_{"UICorner", Label_8,	CornerRadius = UDim.new(0, 4),}; local Close = _New_{"TextButton", TopBar,	AutoButtonColor = false,	BackgroundColor3 = Color3.fromRGB(74.0000031888485, 74.0000031888485, 74.0000031888485),	BorderSizePixel = 0,	Name = "Close",	Position = UDim2.new(1, -28, 0, 4),	Size = UDim2.new(0, 20, 1, -8),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "",	TextColor3 = Color3.fromRGB(210.00001788139343, 210.00001788139343, 210.00001788139343),	TextSize = 14,}; local UICorner_32 = _New_{"UICorner", Close,	CornerRadius = UDim.new(0, 4),}; local Label_9 = _New_{"TextLabel", Close,	BackgroundColor3 = Color3.fromRGB(88.00000235438347, 88.00000235438347, 88.00000235438347),	BorderSizePixel = 0,	Name = "Label",	Position = UDim2.new(0, 3, 0, 3),	Size = UDim2.new(1, -6, 1, -6),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "x",	TextColor3 = Color3.fromRGB(210.00001788139343, 210.00001788139343, 210.00001788139343),	TextSize = 20,}; local UICorner_33 = _New_{"UICorner", Label_9,	CornerRadius = UDim.new(0, 4),}; local PromptHolder = _New_{"Frame", MainFrame,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 0.7799999713897705,	BorderSizePixel = 0,	Name = "PromptHolder",	Size = UDim2.new(1, 0, 1, 0),	Visible = false,}; local PromptContainer = _New_{"Frame", PromptHolder,	BackgroundColor3 = Color3.fromRGB(84.00000259280205, 84.00000259280205, 84.00000259280205),	BorderSizePixel = 0,	Name = "PromptContainer",	Position = UDim2.new(0.30000001192092896, 0, 0.30000001192092896, 0),	Size = UDim2.new(0.4000000059604645, 0, 0.30000001192092896, 0),}; local Prompt = _New_{"Frame", PromptContainer,	BackgroundColor3 = Color3.fromRGB(72.00000330805779, 72.00000330805779, 72.00000330805779),	BorderSizePixel = 0,	Name = "Prompt",	Position = UDim2.new(0, 5, 0, 5),	Size = UDim2.new(1, -10, 1, -10),}; local Title_0 = _New_{"TextLabel", Prompt,	BackgroundColor3 = Color3.fromRGB(255, 255, 255),	BackgroundTransparency = 1,	BorderSizePixel = 0,	Name = "Title",	Position = UDim2.new(0, 4, 0, 4),	Size = UDim2.new(1, -8, 0, 42),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Are you sure you want to reset all values back to default?",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextScaled = true,	TextSize = 14,	TextWrapped = true,}; local YesButton = _New_{"TextButton", Prompt,	BackgroundColor3 = Color3.fromRGB(82.00000271201134, 108.00000876188278, 73.00000324845314),	BorderSizePixel = 0,	Name = "YesButton",	Position = UDim2.new(0.05000000074505806, 0, 0.42500001192092896, -5),	Size = UDim2.new(0.8999999761581421, 0, 0.15000000596046448, 0),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Yes",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 14,}; local UIStroke_0 = _New_{"UIStroke", YesButton,	ApplyStrokeMode = Enum.ApplyStrokeMode.Border,	Color = Color3.fromRGB(162.00000554323196, 162.00000554323196, 162.00000554323196),	Thickness = 2,	Transparency = 0.3999999761581421,}; local NoButton = _New_{"TextButton", Prompt,	BackgroundColor3 = Color3.fromRGB(108.00000876188278, 81.00000277161598, 73.00000324845314),	BorderSizePixel = 0,	Name = "NoButton",	Position = UDim2.new(0.05000000074505806, 0, 0.574999988079071, 5),	Size = UDim2.new(0.8999999761581421, 0, 0.15000000596046448, 0),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "No",	TextColor3 = Color3.fromRGB(255, 255, 255),	TextSize = 14,}; local UIStroke_1 = _New_{"UIStroke", NoButton,	ApplyStrokeMode = Enum.ApplyStrokeMode.Border,	Color = Color3.fromRGB(162.00000554323196, 162.00000554323196, 162.00000554323196),	Thickness = 2,	Transparency = 0.3999999761581421,}; local RightClickMenu = _New_{"Frame", MainFrame,	BackgroundColor3 = Color3.fromRGB(72.00000330805779, 72.00000330805779, 72.00000330805779),	BorderSizePixel = 0,	Name = "RightClickMenu",	Size = UDim2.new(0, 118, 0, 22),	Visible = false,}; local UIStroke_2 = _New_{"UIStroke", RightClickMenu,	Color = Color3.fromRGB(140.00000685453415, 140.00000685453415, 140.00000685453415),}; local ResetToDefault = _New_{"TextButton", RightClickMenu,	BackgroundColor3 = Color3.fromRGB(84.00000259280205, 84.00000259280205, 84.00000259280205),	BorderSizePixel = 0,	Name = "ResetToDefault",	Position = UDim2.new(0, 3, 0, 3),	Size = UDim2.new(1, -6, 0, 16),	Font = Enum.Font.Nunito,	FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),	Text = "Reset to default.",	TextColor3 = Color3.fromRGB(210.00001788139343, 210.00001788139343, 210.00001788139343),	TextSize = 14,}; local UICorner_34 = _New_{"UICorner", MainFrame,	CornerRadius = UDim.new(0, 4),}; return UniversalAimbotAndEspV2;
end;
ModuleExports["ui/ui"] = f_module_ui_ui;
local function f_module_Renderer()
local errhandler = ModuleShared.errhandler; local PlayersService = ModuleShared.PlayersService; local LocalPlayer = ModuleShared.LocalPlayer; return ModuleShared.NewModule("Renderer", { initialize = function(self) self.PlayerObjects = {}; end, stop = function(self) self.RenderSteppedConnection:Disconnect(); self.PlayerAddedConnection:Disconnect(); self.PlayerRemovingConnection:Disconnect(); for _, Object in next, self.PlayerObjects do xpcall(Object.stop, errhandler"Failed to destroy Player_Object when stopping Renderer: ", Object); end; end, start = function(self) self.RenderSteppedConnection = game:GetService("RunService").RenderStepped:Connect(function() self:render(); end); for _, Player in next, PlayersService:GetPlayers() do if Player == LocalPlayer then continue; end; self:addPlayer(Player); end; self.PlayerAddedConnection = PlayersService.PlayerAdded:Connect(function(Player) self:addPlayer(Player); end); self.PlayerRemovingConnection = PlayersService.PlayerRemoving:Connect(function(Player) local playerobject = self.PlayerObjects[Player]; if not playerobject then return warn("PlayerRemoving: " .. Player.Name .. " had no Player_Object"); end; self.PlayerObjects[Player] = nil; playerobject:stop(); end); end, addPlayer = function(self, Player, ...) self.PlayerObjects[Player] = ModuleShared.PlayerObject(Player, ...); end, render = function(self) local render = ModuleShared.PlayerObject.render; for _, Object in next, self.PlayerObjects do task.spawn(render, Object); end; end});
end;
ModuleExports["Renderer"] = f_module_Renderer;
local function f_module_Utils()
local Constants = require("Constants"); local Camera = ModuleShared.Camera; local wtvpp = Camera.WorldToViewportPoint; local function worldToViewportPoint(WorldPosition, customcam)  local Offset, IsVisible = wtvpp(customcam or Camera, WorldPosition); return Vector2.new(Offset.X, Offset.Y), IsVisible, Offset.Z; end; local gpot = Camera.GetPartsObscuringTarget; local function getPartsObscuring(...) return gpot(Camera, ...); end; local function mathmap(value, from_min, from_max, to_min, to_max) return (value - from_min) * (to_max - to_min) / (from_max - from_min) + to_min; end; local function mathround(number, places) number = tostring(number); local character_after_dot_position = number:gmatch("%.()")(); if character_after_dot_position then return tonumber(number:sub(1, character_after_dot_position - 1 + places)); else return tonumber(number); end; end; local UserInputService = Constants.USER_INPUT_SERVICE; local getmouselocation = UserInputService.GetMouseLocation; local function getMousePosition() return getmouselocation(UserInputService); end; local function replacePairs(str, ...) str = " " .. str .. " ";  local args = {...}; for i = 1, #args, 2 do local replacee = args[i]; local replacement = args[i + 1]; str = (str:gsub("(%W)" .. replacee .. "(%W)", "%1" .. replacement .. "%2")); end; return str:sub(2, -2);  end; local KEYCODE_UNKNOWN = Constants.KEYCODE_UNKNOWN; local KEYBIND_USER_INPUT_TYPE_WHITELIST = Constants.KEYBIND_USER_INPUT_TYPE_WHITELIST; local function getKeyFromInput(Input) local KeyCode, UserInputType = Input.KeyCode, Input.UserInputType; KeyCode = KeyCode ~= KEYCODE_UNKNOWN and KeyCode; UserInputType = KEYBIND_USER_INPUT_TYPE_WHITELIST[UserInputType] and UserInputType; local new = (KeyCode) or (UserInputType); return new; end; return { worldToViewportPoint = worldToViewportPoint, getPartsObscuring = getPartsObscuring, mathmap = mathmap, mathround = mathround, getMousePosition = getMousePosition, replacePairs = replacePairs, getKeyFromInput = getKeyFromInput,}
end;
ModuleExports["Utils"] = f_module_Utils;
local function f_module_Constants()
local USER_INPUT_SERVICE = game:GetService("UserInputService"); local USER_INPUT_TYPE = Enum.UserInputType; return { RIGTYPE_R6 = Enum.HumanoidRigType.R6; WHITE = Color3.new(1,1,1); VECTOR2_ZERO = Vector2.new();    NECK_OFFSET = Vector3.new(0, 0.8, 0); VECTOR_DIVIDEND = 2; XVECTOR_DIVIDEND = 3; XVECTOR_LOWER_DIVIDEND = 4; MOUSEBUTTON1 = Enum.UserInputType.MouseButton1; MOUSEBUTTON2 = Enum.UserInputType.MouseButton2;  BEGIN = Enum.UserInputState.Begin, END = Enum.UserInputState.End; CANCEL = Enum.UserInputState.Cancel; MOUSEMOVEMENT = Enum.UserInputType.MouseMovement; RIGHT_CLICK_MENU_OFFSET = Vector3.new(10, -3), USER_INPUT_SERVICE = USER_INPUT_SERVICE, INPUT_BEGAN = USER_INPUT_SERVICE.InputBegan, INPUT_ENDED = USER_INPUT_SERVICE.InputEnded, INPUT_CHANGED = USER_INPUT_SERVICE.InputChanged, KEYCODE_UNKNOWN = Enum.KeyCode.Unknown, CONTEXT_ACTION_SERVICE = game:GetService("ContextActionService"), USER_INPUT_TYPE = USER_INPUT_TYPE, KEYBIND_USER_INPUT_TYPE_WHITELIST = { [USER_INPUT_TYPE.MouseButton1] = true, [USER_INPUT_TYPE.MouseButton2] = true, [USER_INPUT_TYPE.MouseButton3] = true, };};
end;
ModuleExports["Constants"] = f_module_Constants;
local function f_module_Tween()
local TweenService = game:GetService("TweenService"); local Create, Play;do local create = TweenService.Create; Create = function(...) return create(TweenService, ...); end; local Part = Instance.new("Part"); Play = Create(Part, TweenInfo.new(), {Transparency = 1}).Play; Part:Destroy(); end; local Tween = {}; function Tween.PlayNew(...) local tween = Create(...); Play(tween); return tween; end; return Tween;
end;
ModuleExports["Tween"] = f_module_Tween;
local function f_module_Aimbot()
local Tween = require("Tween"); local Config = ModuleShared.Config; local Constants = require("Constants"); local Camera = ModuleShared.Camera; local _, ConfigChangedSignals = require("Config"); local AimbotEnabled = ConfigChangedSignals.AIMBOT_ENABLED; local AimbotStickyAim = ConfigChangedSignals.AIMBOT_STICKY_AIM; local AimbotPart = ConfigChangedSignals.AIMBOT_PART; local AimbotKey = ConfigChangedSignals.AIMBOT_KEY; local AimbotWallCheck = ConfigChangedSignals.AIMBOT_WALL_CHECK; local AimbotDistanceCheck = ConfigChangedSignals.AIMBOT_DISTANCE_CHECK; local AimbotMaxDistance = ConfigChangedSignals.AIMBOT_MAX_DISTANCE; local AimbotTeamCheck = ConfigChangedSignals.AIMBOT_TEAM_CHECK; local AimbotAimType = ConfigChangedSignals.AIMBOT_AIM_TYPE; local AimbotRelativeKp = ConfigChangedSignals.AIMBOT_RELATIVE_KP; local ClosestPlayerMode = ConfigChangedSignals.CLOSEST_PLAYER_MODE; local SmoothAiming = ConfigChangedSignals.SMOOTH_AIMING; local SmoothAimingTime = ConfigChangedSignals.SMOOTH_AIMING_TIME; local USER_INPUT_SERVICE = Constants.USER_INPUT_SERVICE; local INPUT_BEGAN = Constants.INPUT_BEGAN; local INPUT_ENDED = Constants.INPUT_ENDED; local getLocalRootPart = ModuleShared.getLocalRootPart; local getLocalTeam = ModuleShared.getLocalTeam; local Utils = require("Utils"); local getMousePosition = Utils.getMousePosition; local worldToViewportPoint = Utils.worldToViewportPoint; local wallcheck = Utils.wallcheck; local getKeyFromInput = Utils.getKeyFromInput; local KEYCODE = Enum.KeyCode; local function isKeyDown(key) if key.EnumType == KEYCODE then return USER_INPUT_SERVICE:IsKeyDown(key); end; return USER_INPUT_SERVICE:IsMouseButtonPressed(key); end; return ModuleShared.NewModule("Aimbot", { initialize = function(self, playerobjects) self.PlayerObjects = playerobjects; self.StickyAim = Config:get("AIMBOT_STICKY_AIM"); self.AimKey = Config:get("AIMBOT_KEY"); self.AimPart = Config:get("AIMBOT_PART"); self.SmoothAiming = Config:get("SMOOTH_AIMING"); self.SmoothAimingTInfo = TweenInfo.new(Config:get("SMOOTH_AIMING_TIME")); self.WallCheck = Config:get("AIMBOT_WALL_CHECK"); self.DistanceCheck = Config:get("AIMBOT_DISTANCE_CHECK"); self.MaxDistance = Config:get("AIMBOT_MAX_DISTANCE"); self.TeamCheck = Config:get("AIMBOT_TEAM_CHECK"); self.mouseRelativeKp = Config:get("AIMBOT_RELATIVE_KP"); self.ClosestPlayerFunctionMap = { MouseDistance = self.getClosestPlayerToMouse, PhysicalDistance = self.getClosestPlayerSpace }; self.AimFunctionMap = { ["Camera.CFrame"] = self.aimCamera, MouseRelative = self.aimMouseRelative, MouseAbsolute = self.aimMouseAbsolute }; AimbotStickyAim:Connect(function(new) self.StickyAim = new; end); AimbotKey:Connect(function(new) self.AimKey = new; end); AimbotPart:Connect(function(new) self.AimPart = new; end); AimbotEnabled:Connect(function(new) if new then self:connectInputBegan(); if not (self.AimKey and isKeyDown(self.AimKey)) then return; end; self:activate(); else self:stop(); end; end); ClosestPlayerMode:Connect(function(new) self:setClosestPlayerMode(new); end); self:setClosestPlayerMode(Config:get("CLOSEST_PLAYER_MODE")); AimbotAimType:Connect(function(new) self:setAimbotMode(new); end); self:setAimbotMode(Config:get("AIMBOT_AIM_TYPE")); AimbotRelativeKp:Connect(function(new) self.mouseRelativeKp = new; end); SmoothAiming:Connect(function(new) self.SmoothAiming = new; self:stopAimTween(); end); SmoothAimingTime:Connect(function(new) self.SmoothAimingTInfo = TweenInfo.new(new); end); AimbotWallCheck:Connect(function(new) self.WallCheck = new; end); AimbotDistanceCheck:Connect(function(new) self.DistanceCheck = new; end); AimbotMaxDistance:Connect(function(new) self.MaxDistance = new; end); AimbotTeamCheck:Connect(function(new) self.TeamCheck = new; end); if Config:get("AIMBOT_ENABLED") then self:connectInputBegan(); end; end, stop = function(self) self:disconnectInputConnections(); self:disactivate(); end, setClosestPlayerMode = function(self, mode) self.ClosestPlayerFunction = self.ClosestPlayerFunctionMap[mode]; end, setAimbotMode = function(self, mode) self.AimFunction = self.AimFunctionMap[mode]; end, disconnectInputConnections = function(self) if self.InputBeganConnection then self.InputBeganConnection:Disconnect(); self.InputBeganConnection = nil; end; if self.InputEndedConnection then self.InputEndedConnection:Disconnect(); self.InputEndedConnection = nil; end; end, connectInputBegan = function(self) self.InputBeganConnection = INPUT_BEGAN:Connect(function(Input) if USER_INPUT_SERVICE:GetFocusedTextBox() then return; end; local key = getKeyFromInput(Input); if not key or key ~= self.AimKey then return; end; task.spawn(self.activate, self); end); self.InputEndedConnection = INPUT_ENDED:Connect(function(Input) local key = getKeyFromInput(Input); if not key or key ~= self.AimKey then return; end; self:disactivate(); end); end, activate = function(self) self.Active = true; self:getPlayer(); while task.wait() and self.Active do self:stopAimTween(); if not self.StickyAim then self:getPlayer(); end; if not self.player or not self.player.Alive or not self.player.Parts then self:getPlayer(); continue; end; self:AimFunction(self.player_aimpart.Position); end; self:stopAimTween(); end, stopAimTween = function(self) if not self.AimTween then return; end; self.AimTween:Cancel(); self.AimTween = nil; end, disactivate = function(self) self.Active = false; end, getPlayer = function(self) self.player, self.player_aimpart = self:ClosestPlayerFunction(); end, aimCamera = function(self, target) target = CFrame.lookAt(Camera.CFrame.Position, target); if not self.SmoothAiming then Camera.CFrame = target; return; end; self.AimTween = Tween.PlayNew(Camera, self.SmoothAimingTInfo, {CFrame = target}); end, aimMouseRelative = function(self, target) local screenposition, isvisible, depth = worldToViewportPoint(target); if not isvisible then return; end; local mouseposition = getMousePosition(); local distance = mouseposition - screenposition;  local kP = self.mouseRelativeKp;  local feedForward = 1 distance = (distance * kP) + Vector2.new(feedForward * math.sign(distance.X), feedForward * math.sign(distance.Y)); distance = -distance; mousemoverel(distance.X, distance.Y); end, aimMouseAbsolute = function(self, target) local screenposition, isvisible, depth = worldToViewportPoint(target); if not isvisible then return; end; mousemoveabs(screenposition.X, screenposition.Y); end, getClosestPlayerToMouse = function(self) local Closest, MaxDistance, AimPart; local MousePosition = getMousePosition(); for _, Object in next, self.PlayerObjects do if not Object.Character or not Object.Parts then continue; end; if not self:doTeamCheck(Object.Team) then continue; end; local HumanoidRootPart = Object.Parts.HumanoidRootPart; if not HumanoidRootPart then continue; end; local ScreenPosition, IsVisible = worldToViewportPoint(HumanoidRootPart.Position); if not IsVisible then continue; end; local aimpart = Object.Parts[self.AimPart] or Object.Parts.HumanoidRootPart; if not aimpart then continue; end; if not self:doWallCheck(aimpart, Object.Character) then continue; end; local Position = HumanoidRootPart.Position; if not self:doDistanceCheck(Position) then continue; end; local Distance = (ScreenPosition - MousePosition).Magnitude; if (not Closest) or (Distance < MaxDistance) then Closest = Object; MaxDistance = Distance; AimPart = aimpart; end; end; return Closest, AimPart; end, getClosestPlayerSpace = function(self) if not getLocalRootPart() then return; end; local Closest, MaxDistance, AimPart; local SpacePosition = getLocalRootPart().Position; for _, Object in next, self.PlayerObjects do if not Object.Character or not Object.Parts then continue; end; if not self:doTeamCheck(Object.Team) then continue; end; local HumanoidRootPart = Object.Parts.HumanoidRootPart; if not HumanoidRootPart then continue; end; local aimpart = Object.Parts[self.AimPart] or Object.Parts.HumanoidRootPart; if not aimpart then continue; end; if not self:doWallCheck(aimpart, Object.Character) then continue; end; local Position = HumanoidRootPart.Position; if not self:doDistanceCheck(Position) then continue; end; local Distance = (SpacePosition - Position).Magnitude; if (not Closest) or (Distance < MaxDistance) then Closest = Object; MaxDistance = Distance; AimPart = aimpart; end; end; return Closest, AimPart; end, doWallCheck = function(self, part, character) if not self.WallCheck then return true; end; return wallcheck({part.Position}, character); end, doDistanceCheck = function(self, position) if not self.DistanceCheck then return true; end; if not getLocalRootPart() then return false; end; local localposition = getLocalRootPart().Position; return (localposition - position).Magnitude <= self.MaxDistance; end, doTeamCheck = function(self, Team) if not self.TeamCheck then return true; end; local LocalTeam = getLocalTeam(); if Team == nil and LocalTeam == nil then return true; end; if Team == LocalTeam then return false; end; return true; end,});
end;
ModuleExports["Aimbot"] = f_module_Aimbot;
local function f_module_Config()
local AutoEntryTable = require("AutoEntryTable"); local Signal = require("Signal"); local Config = {};Config.__index = Config; function Config:__newindex(key, value) self:set(key, value); end; local InitialValues = {}; local DefaultsLookup = {}; local folderpattern = "([^/]+/)"; local changedsignals = AutoEntryTable.new(Signal.new); function Config.new(path) local data = {}; if isfile(path) then pcall(function() data = loadfile(path)(); end); else if path:find("/") then local folderpath = ""; for name in path:gmatch(folderpattern) do if not isfolder(folderpath .. name) then makefolder(folderpath .. name); end; folderpath ..= name; end; end; writefile(path, "return{}"); end; return setmetatable( { _path = path, _data = data }, Config ); end; function Config:get(key) return self._data[key]; end; function Config:set(key, value, ...) self._data[key] = value; changedsignals[key]:Fire(value, ...); self:write(); end; function Config:default(key, value, fakevalue) if type(self._data[key]) == "nil" then self:set(key, value); end; DefaultsLookup[key] = value; value = self:get(key); if type(value) == "nil" then value = fakevalue; end; table.insert(InitialValues, {key,  value }); return changedsignals[key]; end; function Config:defaultCustom(key, value, custom) if type(self._data[key]) == "nil" then self:set(key, value); end; DefaultsLookup[key] = value; value = self:get(key); table.insert(custom, 1, key); table.insert(custom, 2, value); table.insert(InitialValues, custom); return changedsignals[key]; end; function Config:defaultDropdown(key, value, dropdownoptions) return self:defaultCustom(key, value, { dropdownoptions = dropdownoptions }); end; function Config:defaultSlider(key, value, min, max) min = min or 0; max = max or 50; return self:defaultCustom(key, value, { range = { min = min, max = max } }); end; local tostring2 = loadstring(game:HttpGet"https://gitlab.com/te4224/Scripts/-/raw/main/Chrysalism/V1/tostring2.lua")(); function Config:write() writefile(self._path, "return " .. tostring2(self._data)); end; local UISections = setmetatable({}, { __call = function(self, name) self[#InitialValues + 1] = name;  end}); return Config, changedsignals, InitialValues, DefaultsLookup, UISections;
end;
ModuleExports["Config"] = f_module_Config;

local function errhandler(premessage) return function(err) warn(premessage .. err); end; end; ModuleShared.errhandler = errhandler; local CoreGui = game.Players.LocalPlayer:WaitForChild("PlayerGui"); if CoreGui:FindFirstChild("UniversalAimbotAndEspV2") then CoreGui.UniversalAimbotAndEspV2:Destroy(); end; local Constants = require("Constants"); local ConfigClass, _, _, _, UISections = require("Config"); local Config = ConfigClass.new("Universal Aimbot N Esp V2.0 Config.lua"); ModuleShared.Config = Config; local Shared = { Active = true, Config = Config, Connections = {}, Actions = {}}; ModuleShared.Shared = Shared; if shared.UniversalAimbotAndEspV2 then xpcall(shared.UniversalAimbotAndEspV2.stop, errhandler"UAAESPV2:"); end; local Camera = workspace.CurrentCamera; ModuleShared.Camera = Camera; local Utils = require("Utils"); local ScreenEdge = Camera.ViewportSize; local ScreenMiddle = ScreenEdge / 2; local FieldOfView = Camera.FieldOfView; ModuleShared.getScreenEdge = function() return ScreenEdge; end; ModuleShared.getScreenMiddle = function() return ScreenMiddle; end; ModuleShared.getFieldOfView = function() return FieldOfView; end; table.insert(Shared.Connections, Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function() ScreenEdge = Camera.ViewportSize; ScreenMiddle = ScreenEdge / 2; end)); table.insert(Shared.Connections, Camera:GetPropertyChangedSignal("FieldOfView"):Connect(function() FieldOfView = Camera.FieldOfView; end)); local PlayersService = game:GetService("Players"); ModuleShared.PlayersService = PlayersService; local LocalPlayer = PlayersService.LocalPlayer; ModuleShared.LocalPlayer = LocalPlayer; local LocalCharacter, LocalRootPart; local function localCharacterAdded(Character) LocalCharacter = Character; LocalRootPart = Character:FindFirstChild("HumanoidRootPart"); local Con; Con = Character.ChildAdded:Connect(function(Child) if Child.Name == "HumanoidRootPart" then LocalRootPart = Child; Con:Disconnect(); end; end); end if LocalPlayer.Character then localCharacterAdded(LocalPlayer.Character); end; LocalPlayer.CharacterAdded:Connect(localCharacterAdded); ModuleShared.getLocalRootPart = function() return LocalRootPart; end; local LocalTeam = LocalPlayer.Team; LocalPlayer:GetPropertyChangedSignal("Team"):Connect(function() LocalTeam = LocalPlayer.Team; end); ModuleShared.getLocalTeam = function() return LocalTeam; end; local getPartsObscuring = Utils.getPartsObscuring; local function wallcheck(castpoints, character) if not LocalCharacter or not character then return false; end; local ignorelist = {LocalCharacter};   local partsobscuring = getPartsObscuring(castpoints, ignorelist); if #partsobscuring < 1 then return true; end; for _, part in next, partsobscuring do if not part:IsDescendantOf(character) then return false; end; end; return true; end; Utils.wallcheck = wallcheck; UISections("AIMBOT"); Config:default("AIMBOT_ENABLED", true); Config:default("AIMBOT_STICKY_AIM", false); Config:default("AIMBOT_KEY", Enum.KeyCode.E); Config:default("AIMBOT_PART", "HumanoidRootPart"); Config:default("AIMBOT_WALL_CHECK", true); Config:default("AIMBOT_DISTANCE_CHECK", false); Config:defaultSlider("AIMBOT_MAX_DISTANCE", 500, 0, 500); Config:default("AIMBOT_TEAM_CHECK", true); Config:defaultDropdown("AIMBOT_AIM_TYPE", "Camera.CFrame", { "Camera.CFrame", "MouseRelative", "MouseAbsolute"}); Config:defaultSlider("AIMBOT_RELATIVE_KP", 0.05, 0.01, 0.1); Config:defaultDropdown("CLOSEST_PLAYER_MODE", "MouseDistance", { "MouseDistance", "PhysicalDistance"}); Config:default("SMOOTH_AIMING", false); Config:defaultSlider("SMOOTH_AIMING_TIME", 0.08, 0.08, 1); UISections("ESP"); Config:default("ESP_DISTANCE_CHECK", false); Config:defaultSlider("ESP_MAX_DISTANCE", 500, 0, 500); Config:default("ESP_TEAM_CHECK", true); UISections("NAMETAG"); Config:default("NAMETAG_ENABLED", true); Config:default("NAMETAG_3D_VERTICAL_OFFSET", Vector3.new(0, 2, 0)); Config:default("NAMETAG_TEXT", "NAME | HEALTH/MAXHEALTH | DISTANCE"); Config:defaultSlider("MINIMUM_TEXT_SIZE", 16, 4); Config:defaultSlider("MAXIMUM_TEXT_SIZE", 22, 4); UISections("BOX") Config:default("BOX_ENABLED", true); Config:default("3DBOX_ENABLED", true); Config:default("2DBOX_ENABLED", false); Config:default("3DBOX_VERTICAL_OFFSET", Vector3.new(0, 1, 0)); Config:defaultSlider("BOX_THICKNESS", 4, 0, 10); Config:defaultSlider("BOX_TRANSPARENCY", 0.55, 0.1, 1); Config:default("BOX_FILLED", false); UISections("TRACER"); Config:default("TRACER_ENABLED", true); Config:default("TRACER_PART", "Head"); Config:defaultDropdown("TRACER_FROM", "Middle", { "Top", "Middle", "Bottom"}); UISections("SKELETON"); Config:default("SKELETON_ENABLED", true); Config:defaultSlider("SKELETON_THICKNESS", 3, 0, 10); Config:defaultSlider("SKELETON_TRANSPARENCY", 1, 0.1, 1); UISections("COLORS"); Config:default("BASE_COLOR", Constants.WHITE); Config:default("NAMETAG_COLOR", nil, Constants.WHITE); Config:default("BOX_COLOR", nil, Constants.WHITE); Config:default("TRACER_COLOR", nil, Constants.WHITE); Config:default("SKELETON_COLOR", nil, Constants.WHITE); UISections("UI"); Config:default("TEXT_USE_PLACEHOLDER_TEXT", false); Config:default("STRUCT_USE_PLACEHOLDER_TEXT", true); local function getTracerFrom(thickness) local from = Config:get("TRACER_FROM"); if from == "Middle" then return ScreenMiddle; elseif from == "Bottom" then return Vector2.new(ScreenMiddle.X, ScreenEdge.Y - thickness); elseif from == "Top" then return Vector2.new(ScreenMiddle.X, thickness); end; end; Utils.getTracerFrom = getTracerFrom; local game__index = getrawmetatable(game).__index;  local overrides = {  getCharacter = function(_,Player) return game__index(Player, "Character"); end, getCharacterAddedSignal = function(_,Player) return game__index(Player, "CharacterAdded"); end, getDestroyedSignal = function(_,Character) return game__index(Character, "AncestryChanged"); end}; ModuleShared.overrides = overrides; local gameidoverrides = { [142553158] = {  init = function(self) local function secure_call(func, ...) local a = {...};local b = {};task.spawn(function()syn.set_thread_identity(2);b={func(table.unpack(a))};end);repeat task.wait()until b;return table.unpack(b); end; local a = ModuleShared.oldrequire(game.ReplicatedStorage:WaitForChild("BAC"):WaitForChild("Characters"));local b = getrawmetatable(a).__index;local c = secure_call(b, a, "GetCharacter"); self.GetCharacter = function(...) return secure_call(c, ...); end; end, getCharacter = function(self, Player) return self.GetCharacter(Player); end, }}; local placeidoverrides = {}; local function getOverrides() return placeidoverrides[game.PlaceId] or gameidoverrides[game.GameId]; end; local middleclass = require("middleclass"); local function NewModule(name, info) assert(info.initialize, "Failed to create a new module with name '" .. name .. "' because 'initialize' was not found in info."); local module = middleclass(name); for k,v in next, info do module[k] = v; end; return module; end; ModuleShared.NewModule = NewModule; local PlayerObject = require("PlayerObject"); ModuleShared.PlayerObject = PlayerObject; local Renderer = require("Renderer"); local Aimbot = require("Aimbot"); Renderer = Renderer(); Aimbot = Aimbot(Renderer.PlayerObjects); local CONTEXT_ACTION_SERVICE = Constants.CONTEXT_ACTION_SERVICE; function Shared.stop() shared.UniversalAimbotAndEspV2 = nil; Shared.Active = false; Renderer:stop(); Aimbot:stop(); for _, Connection in next, Shared.Connections do pcall(Connection.Disconnect, Connection); end; for _, ActionName in next, Shared.Actions do CONTEXT_ACTION_SERVICE:UnbindCoreAction(ActionName); end; if Shared.UI then Shared.UI:Destroy(); end; end; shared.UniversalAimbotAndEspV2 = Shared; xpcall(Renderer.render, function(err) warn("Failed to call render: " .. tostring(err)); Shared.stop(); end, Renderer); local function copyOverrides(new) for k,v in next, new do overrides[k] = v; end; return new; end; local function initializeOverrides(o) if o.init then o:init(); end; return o; end; local Interface = { stop = Shared.stop, overrides = overrides, Config = Config, setOverrides = function(new) overrides = new; ModuleShared.overrides = new; end,}; local newoverrides = shared._overrides_ or getOverrides(); if newoverrides then copyOverrides(initializeOverrides(newoverrides)); task.wait(0.5); end; Renderer:start(); Shared.UI = require("ui"); return Interface;
